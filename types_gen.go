// Code generated by acp-go-generator; DO NOT EDIT.

package acp

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
)

// Capabilities supported by the agent.
//
// Advertised during initialization to inform the client about
// available features and content types.
//
// See protocol docs: [Agent Capabilities](https://agentclientprotocol.com/protocol/initialization#agent-capabilities)
type AgentCapabilities struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// Whether the agent supports 'session/load'.
	//
	// Defaults to false if unset.
	LoadSession bool `json:"loadSession,omitempty"`
	// MCP capabilities supported by the agent.
	//
	// Defaults to {"http":false,"sse":false} if unset.
	McpCapabilities McpCapabilities `json:"mcpCapabilities,omitempty"`
	// Prompt capabilities supported by the agent.
	//
	// Defaults to {"audio":false,"embeddedContext":false,"image":false} if unset.
	PromptCapabilities PromptCapabilities `json:"promptCapabilities,omitempty"`
	// Defaults to {} if unset.
	SessionCapabilities SessionCapabilities `json:"sessionCapabilities,omitempty"`
}

func (v AgentCapabilities) MarshalJSON() ([]byte, error) {
	type Alias AgentCapabilities
	var a Alias
	a = Alias(v)
	return json.Marshal(a)
}

func (v *AgentCapabilities) UnmarshalJSON(b []byte) error {
	var m map[string]json.RawMessage
	if err := json.Unmarshal(b, &m); err != nil {
		return err
	}
	type Alias AgentCapabilities
	var a Alias
	if err := json.Unmarshal(b, &a); err != nil {
		return err
	}
	{
		_rm, _ok := m["loadSession"]
		if !_ok || (string(_rm) == "null") {
			json.Unmarshal([]byte("false"), &a.LoadSession)
		}
	}
	{
		_rm, _ok := m["mcpCapabilities"]
		if !_ok || (string(_rm) == "null") {
			json.Unmarshal([]byte("{\"http\":false,\"sse\":false}"), &a.McpCapabilities)
		}
	}
	{
		_rm, _ok := m["promptCapabilities"]
		if !_ok || (string(_rm) == "null") {
			json.Unmarshal([]byte("{\"audio\":false,\"embeddedContext\":false,\"image\":false}"), &a.PromptCapabilities)
		}
	}
	{
		_rm, _ok := m["sessionCapabilities"]
		if !_ok || (string(_rm) == "null") {
			json.Unmarshal([]byte("{}"), &a.SessionCapabilities)
		}
	}
	*v = AgentCapabilities(a)
	return nil
}

type AgentNotification struct {
	Method string `json:"method"`
	Params any    `json:"params,omitempty"`
}

func (v *AgentNotification) Validate() error {
	if v.Method == "" {
		return fmt.Errorf("method is required")
	}
	return nil
}

type AgentRequest struct {
	Id     RequestId `json:"id"`
	Method string    `json:"method"`
	Params any       `json:"params,omitempty"`
}

func (v *AgentRequest) Validate() error {
	if v.Method == "" {
		return fmt.Errorf("method is required")
	}
	return nil
}

type AgentResult struct {
	Id RequestId `json:"id"`
	// All possible responses that an agent can send to a client.
	//
	// This enum is used internally for routing RPC responses. You typically won't need
	// to use this directly - the responses are handled automatically by the connection.
	//
	// These are responses to the corresponding 'ClientRequest' variants.
	Result any `json:"result"`
}

type AgentError struct {
	Error Error     `json:"error"`
	Id    RequestId `json:"id"`
}

type AgentResponse struct {
	Result *AgentResult `json:"-"`
	Error  *AgentError  `json:"-"`
}

func (u *AgentResponse) UnmarshalJSON(b []byte) error {
	var m map[string]json.RawMessage
	if err := json.Unmarshal(b, &m); err == nil {
		{
			var v AgentResult
			var match bool = true
			if _, ok := m["id"]; !ok {
				match = false
			}
			if _, ok := m["result"]; !ok {
				match = false
			}
			if match {
				if json.Unmarshal(b, &v) != nil {
					return errors.New("invalid variant payload")
				}
				u.Result = &v
				return nil
			}
		}
		{
			var v AgentError
			var match bool = true
			if _, ok := m["id"]; !ok {
				match = false
			}
			if _, ok := m["error"]; !ok {
				match = false
			}
			if match {
				if json.Unmarshal(b, &v) != nil {
					return errors.New("invalid variant payload")
				}
				u.Error = &v
				return nil
			}
		}
	} else {
		if _, ok := err.(*json.UnmarshalTypeError); !ok {
			return err
		}
	}
	{
		var v AgentResult
		if json.Unmarshal(b, &v) == nil {
			u.Result = &v
			return nil
		}
	}
	{
		var v AgentError
		if json.Unmarshal(b, &v) == nil {
			u.Error = &v
			return nil
		}
	}
	return nil
}
func (u AgentResponse) MarshalJSON() ([]byte, error) {
	if u.Result != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.Result)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	if u.Error != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.Error)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	return []byte{}, nil
}

// Optional annotations for the client. The client can use annotations to inform how objects are used or displayed
type Annotations struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta         map[string]any `json:"_meta,omitempty"`
	Audience     []Role         `json:"audience,omitempty"`
	LastModified *string        `json:"lastModified,omitempty"`
	Priority     *float64       `json:"priority,omitempty"`
}

// Audio provided to or from an LLM.
type AudioContent struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta        map[string]any `json:"_meta,omitempty"`
	Annotations *Annotations   `json:"annotations,omitempty"`
	Data        string         `json:"data"`
	MimeType    string         `json:"mimeType"`
}

// Describes an available authentication method.
type AuthMethod struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// Optional description providing more details about this authentication method.
	Description *string `json:"description,omitempty"`
	// Unique identifier for this authentication method.
	Id string `json:"id"`
	// Human-readable name of the authentication method.
	Name string `json:"name"`
}

// Request parameters for the authenticate method.
//
// Specifies which authentication method to use.
type AuthenticateRequest struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// The ID of the authentication method to use.
	// Must be one of the methods advertised in the initialize response.
	MethodId string `json:"methodId"`
}

func (v *AuthenticateRequest) Validate() error {
	if v.MethodId == "" {
		return fmt.Errorf("methodId is required")
	}
	return nil
}

// Response to the 'authenticate' method.
type AuthenticateResponse struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
}

func (v *AuthenticateResponse) Validate() error {
	return nil
}

// Information about a command.
type AvailableCommand struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// Human-readable description of what the command does.
	Description string `json:"description"`
	// Input for the command if required
	Input *AvailableCommandInput `json:"input,omitempty"`
	// Command name (e.g., 'create_plan', 'research_codebase').
	Name string `json:"name"`
}

// The input specification for a command.
type AvailableCommandInput struct {
	// All text that was typed after the command name is provided as input.
	Unstructured *UnstructuredCommandInput `json:"-"`
}

func (u *AvailableCommandInput) UnmarshalJSON(b []byte) error {
	var m map[string]json.RawMessage
	if err := json.Unmarshal(b, &m); err == nil {
		{
			var v UnstructuredCommandInput
			var match bool = true
			if _, ok := m["hint"]; !ok {
				match = false
			}
			if match {
				if json.Unmarshal(b, &v) != nil {
					return errors.New("invalid variant payload")
				}
				u.Unstructured = &v
				return nil
			}
		}
	} else {
		if _, ok := err.(*json.UnmarshalTypeError); !ok {
			return err
		}
	}
	{
		var v UnstructuredCommandInput
		if json.Unmarshal(b, &v) == nil {
			u.Unstructured = &v
			return nil
		}
	}
	return nil
}
func (u AvailableCommandInput) MarshalJSON() ([]byte, error) {
	if u.Unstructured != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.Unstructured)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	return []byte{}, nil
}

// Available commands are ready or have changed
type AvailableCommandsUpdate struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// Commands the agent can execute
	AvailableCommands []AvailableCommand `json:"availableCommands"`
}

// Binary resource contents.
type BlobResourceContents struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta     map[string]any `json:"_meta,omitempty"`
	Blob     string         `json:"blob"`
	MimeType *string        `json:"mimeType,omitempty"`
	Uri      string         `json:"uri"`
}

// Notification to cancel ongoing operations for a session.
//
// See protocol docs: [Cancellation](https://agentclientprotocol.com/protocol/prompt-turn#cancellation)
type CancelNotification struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// The ID of the session to cancel operations for.
	SessionId SessionId `json:"sessionId"`
}

func (v *CancelNotification) Validate() error {
	return nil
}

// Capabilities supported by the client.
//
// Advertised during initialization to inform the agent about
// available features and methods.
//
// See protocol docs: [Client Capabilities](https://agentclientprotocol.com/protocol/initialization#client-capabilities)
type ClientCapabilities struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// File system capabilities supported by the client.
	// Determines which file operations the agent can request.
	//
	// Defaults to {"readTextFile":false,"writeTextFile":false} if unset.
	Fs FileSystemCapability `json:"fs,omitempty"`
	// Whether the Client support all 'terminal/*' methods.
	//
	// Defaults to false if unset.
	Terminal bool `json:"terminal,omitempty"`
}

func (v ClientCapabilities) MarshalJSON() ([]byte, error) {
	type Alias ClientCapabilities
	var a Alias
	a = Alias(v)
	return json.Marshal(a)
}

func (v *ClientCapabilities) UnmarshalJSON(b []byte) error {
	var m map[string]json.RawMessage
	if err := json.Unmarshal(b, &m); err != nil {
		return err
	}
	type Alias ClientCapabilities
	var a Alias
	if err := json.Unmarshal(b, &a); err != nil {
		return err
	}
	{
		_rm, _ok := m["fs"]
		if !_ok || (string(_rm) == "null") {
			json.Unmarshal([]byte("{\"readTextFile\":false,\"writeTextFile\":false}"), &a.Fs)
		}
	}
	{
		_rm, _ok := m["terminal"]
		if !_ok || (string(_rm) == "null") {
			json.Unmarshal([]byte("false"), &a.Terminal)
		}
	}
	*v = ClientCapabilities(a)
	return nil
}

type ClientNotification struct {
	Method string `json:"method"`
	Params any    `json:"params,omitempty"`
}

func (v *ClientNotification) Validate() error {
	if v.Method == "" {
		return fmt.Errorf("method is required")
	}
	return nil
}

type ClientRequest struct {
	Id     RequestId `json:"id"`
	Method string    `json:"method"`
	Params any       `json:"params,omitempty"`
}

func (v *ClientRequest) Validate() error {
	if v.Method == "" {
		return fmt.Errorf("method is required")
	}
	return nil
}

type ClientResult struct {
	Id RequestId `json:"id"`
	// All possible responses that a client can send to an agent.
	//
	// This enum is used internally for routing RPC responses. You typically won't need
	// to use this directly - the responses are handled automatically by the connection.
	//
	// These are responses to the corresponding 'AgentRequest' variants.
	Result any `json:"result"`
}

type ClientError struct {
	Error Error     `json:"error"`
	Id    RequestId `json:"id"`
}

type ClientResponse struct {
	Result *ClientResult `json:"-"`
	Error  *ClientError  `json:"-"`
}

func (u *ClientResponse) UnmarshalJSON(b []byte) error {
	var m map[string]json.RawMessage
	if err := json.Unmarshal(b, &m); err == nil {
		{
			var v ClientResult
			var match bool = true
			if _, ok := m["id"]; !ok {
				match = false
			}
			if _, ok := m["result"]; !ok {
				match = false
			}
			if match {
				if json.Unmarshal(b, &v) != nil {
					return errors.New("invalid variant payload")
				}
				u.Result = &v
				return nil
			}
		}
		{
			var v ClientError
			var match bool = true
			if _, ok := m["id"]; !ok {
				match = false
			}
			if _, ok := m["error"]; !ok {
				match = false
			}
			if match {
				if json.Unmarshal(b, &v) != nil {
					return errors.New("invalid variant payload")
				}
				u.Error = &v
				return nil
			}
		}
	} else {
		if _, ok := err.(*json.UnmarshalTypeError); !ok {
			return err
		}
	}
	{
		var v ClientResult
		if json.Unmarshal(b, &v) == nil {
			u.Result = &v
			return nil
		}
	}
	{
		var v ClientError
		if json.Unmarshal(b, &v) == nil {
			u.Error = &v
			return nil
		}
	}
	return nil
}
func (u ClientResponse) MarshalJSON() ([]byte, error) {
	if u.Result != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.Result)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	if u.Error != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.Error)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	return []byte{}, nil
}

// Standard content block (text, images, resources).
type Content struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// The actual content block.
	Content ContentBlock `json:"content"`
}

// Content blocks represent displayable information in the Agent Client Protocol.
//
// They provide a structured way to handle various types of user-facing content—whether
// it's text from language models, images for analysis, or embedded resources for context.
//
// Content blocks appear in:
// - User prompts sent via 'session/prompt'
// - Language model output streamed through 'session/update' notifications
// - Progress updates and results from tool calls
//
// This structure is compatible with the Model Context Protocol (MCP), enabling
// agents to seamlessly forward content from MCP tool outputs without transformation.
//
// See protocol docs: [Content](https://agentclientprotocol.com/protocol/content)
// Text content. May be plain text or formatted with Markdown.
//
// All agents MUST support text content blocks in prompts.
// Clients SHOULD render this text as Markdown.
type ContentBlockText struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta        map[string]any `json:"_meta,omitempty"`
	Annotations *Annotations   `json:"annotations,omitempty"`
	Text        string         `json:"text"`
	Type        string         `json:"type"`
}

// Images for visual context or analysis.
//
// Requires the 'image' prompt capability when included in prompts.
type ContentBlockImage struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta        map[string]any `json:"_meta,omitempty"`
	Annotations *Annotations   `json:"annotations,omitempty"`
	Data        string         `json:"data"`
	MimeType    string         `json:"mimeType"`
	Type        string         `json:"type"`
	Uri         *string        `json:"uri,omitempty"`
}

// Audio data for transcription or analysis.
//
// Requires the 'audio' prompt capability when included in prompts.
type ContentBlockAudio struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta        map[string]any `json:"_meta,omitempty"`
	Annotations *Annotations   `json:"annotations,omitempty"`
	Data        string         `json:"data"`
	MimeType    string         `json:"mimeType"`
	Type        string         `json:"type"`
}

// References to resources that the agent can access.
//
// All agents MUST support resource links in prompts.
type ContentBlockResourceLink struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta        map[string]any `json:"_meta,omitempty"`
	Annotations *Annotations   `json:"annotations,omitempty"`
	Description *string        `json:"description,omitempty"`
	MimeType    *string        `json:"mimeType,omitempty"`
	Name        string         `json:"name"`
	Size        *int           `json:"size,omitempty"`
	Title       *string        `json:"title,omitempty"`
	Type        string         `json:"type"`
	Uri         string         `json:"uri"`
}

// Complete resource contents embedded directly in the message.
//
// Preferred for including context as it avoids extra round-trips.
//
// Requires the 'embeddedContext' prompt capability when included in prompts.
type ContentBlockResource struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta        map[string]any           `json:"_meta,omitempty"`
	Annotations *Annotations             `json:"annotations,omitempty"`
	Resource    EmbeddedResourceResource `json:"resource"`
	Type        string                   `json:"type"`
}

type ContentBlock struct {
	// Text content. May be plain text or formatted with Markdown.
	//
	// All agents MUST support text content blocks in prompts.
	// Clients SHOULD render this text as Markdown.
	Text *ContentBlockText `json:"-"`
	// Images for visual context or analysis.
	//
	// Requires the 'image' prompt capability when included in prompts.
	Image *ContentBlockImage `json:"-"`
	// Audio data for transcription or analysis.
	//
	// Requires the 'audio' prompt capability when included in prompts.
	Audio *ContentBlockAudio `json:"-"`
	// References to resources that the agent can access.
	//
	// All agents MUST support resource links in prompts.
	ResourceLink *ContentBlockResourceLink `json:"-"`
	// Complete resource contents embedded directly in the message.
	//
	// Preferred for including context as it avoids extra round-trips.
	//
	// Requires the 'embeddedContext' prompt capability when included in prompts.
	Resource *ContentBlockResource `json:"-"`
}

func (u *ContentBlock) UnmarshalJSON(b []byte) error {
	var m map[string]json.RawMessage
	if err := json.Unmarshal(b, &m); err == nil {
		{
			var disc string
			if v, ok := m["type"]; ok {
				json.Unmarshal(v, &disc)
			}
			switch disc {
			case "text":
				var v ContentBlockText
				if json.Unmarshal(b, &v) != nil {
					return errors.New("invalid variant payload")
				}
				u.Text = &v
				return nil
			case "image":
				var v ContentBlockImage
				if json.Unmarshal(b, &v) != nil {
					return errors.New("invalid variant payload")
				}
				u.Image = &v
				return nil
			case "audio":
				var v ContentBlockAudio
				if json.Unmarshal(b, &v) != nil {
					return errors.New("invalid variant payload")
				}
				u.Audio = &v
				return nil
			case "resource_link":
				var v ContentBlockResourceLink
				if json.Unmarshal(b, &v) != nil {
					return errors.New("invalid variant payload")
				}
				u.ResourceLink = &v
				return nil
			case "resource":
				var v ContentBlockResource
				if json.Unmarshal(b, &v) != nil {
					return errors.New("invalid variant payload")
				}
				u.Resource = &v
				return nil
			}
		}
		{
			var v ContentBlockText
			var match bool = true
			if _, ok := m["type"]; !ok {
				match = false
			}
			if _, ok := m["text"]; !ok {
				match = false
			}
			if match {
				if json.Unmarshal(b, &v) != nil {
					return errors.New("invalid variant payload")
				}
				u.Text = &v
				return nil
			}
		}
		{
			var v ContentBlockImage
			var match bool = true
			if _, ok := m["type"]; !ok {
				match = false
			}
			if _, ok := m["data"]; !ok {
				match = false
			}
			if _, ok := m["mimeType"]; !ok {
				match = false
			}
			if match {
				if json.Unmarshal(b, &v) != nil {
					return errors.New("invalid variant payload")
				}
				u.Image = &v
				return nil
			}
		}
		{
			var v ContentBlockAudio
			var match bool = true
			if _, ok := m["type"]; !ok {
				match = false
			}
			if _, ok := m["data"]; !ok {
				match = false
			}
			if _, ok := m["mimeType"]; !ok {
				match = false
			}
			if match {
				if json.Unmarshal(b, &v) != nil {
					return errors.New("invalid variant payload")
				}
				u.Audio = &v
				return nil
			}
		}
		{
			var v ContentBlockResourceLink
			var match bool = true
			if _, ok := m["type"]; !ok {
				match = false
			}
			if _, ok := m["name"]; !ok {
				match = false
			}
			if _, ok := m["uri"]; !ok {
				match = false
			}
			if match {
				if json.Unmarshal(b, &v) != nil {
					return errors.New("invalid variant payload")
				}
				u.ResourceLink = &v
				return nil
			}
		}
		{
			var v ContentBlockResource
			var match bool = true
			if _, ok := m["type"]; !ok {
				match = false
			}
			if _, ok := m["resource"]; !ok {
				match = false
			}
			if match {
				if json.Unmarshal(b, &v) != nil {
					return errors.New("invalid variant payload")
				}
				u.Resource = &v
				return nil
			}
		}
	} else {
		if _, ok := err.(*json.UnmarshalTypeError); !ok {
			return err
		}
	}
	{
		var v ContentBlockText
		if json.Unmarshal(b, &v) == nil {
			u.Text = &v
			return nil
		}
	}
	{
		var v ContentBlockImage
		if json.Unmarshal(b, &v) == nil {
			u.Image = &v
			return nil
		}
	}
	{
		var v ContentBlockAudio
		if json.Unmarshal(b, &v) == nil {
			u.Audio = &v
			return nil
		}
	}
	{
		var v ContentBlockResourceLink
		if json.Unmarshal(b, &v) == nil {
			u.ResourceLink = &v
			return nil
		}
	}
	{
		var v ContentBlockResource
		if json.Unmarshal(b, &v) == nil {
			u.Resource = &v
			return nil
		}
	}
	return nil
}
func (u ContentBlock) MarshalJSON() ([]byte, error) {
	if u.Text != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.Text)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		m["type"] = "text"
		{
			var nm map[string]any
			nm = make(map[string]any)
			nm["type"] = "text"
			nm["text"] = m["text"]
			return json.Marshal(nm)
		}
	}
	if u.Image != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.Image)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		m["type"] = "image"
		{
			var nm map[string]any
			nm = make(map[string]any)
			nm["type"] = "image"
			nm["data"] = m["data"]
			nm["mimeType"] = m["mimeType"]
			if _v, _ok := m["uri"]; _ok {
				nm["uri"] = _v
			}
			return json.Marshal(nm)
		}
	}
	if u.Audio != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.Audio)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		m["type"] = "audio"
		{
			var nm map[string]any
			nm = make(map[string]any)
			nm["type"] = "audio"
			nm["data"] = m["data"]
			nm["mimeType"] = m["mimeType"]
			return json.Marshal(nm)
		}
	}
	if u.ResourceLink != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.ResourceLink)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		m["type"] = "resource_link"
		{
			var nm map[string]any
			nm = make(map[string]any)
			nm["type"] = "resource_link"
			nm["name"] = m["name"]
			nm["uri"] = m["uri"]
			if v1, ok1 := m["description"]; ok1 {
				nm["description"] = v1
			}
			if v2, ok2 := m["mimeType"]; ok2 {
				nm["mimeType"] = v2
			}
			if v3, ok3 := m["size"]; ok3 {
				nm["size"] = v3
			}
			if v4, ok4 := m["title"]; ok4 {
				nm["title"] = v4
			}
			return json.Marshal(nm)
		}
	}
	if u.Resource != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.Resource)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		m["type"] = "resource"
		{
			var nm map[string]any
			nm = make(map[string]any)
			nm["type"] = "resource"
			nm["resource"] = m["resource"]
			return json.Marshal(nm)
		}
	}
	return []byte{}, nil
}

func (u *ContentBlock) Validate() error {
	var count int
	if u.Text != nil {
		count++
	}
	if u.Image != nil {
		count++
	}
	if u.Audio != nil {
		count++
	}
	if u.ResourceLink != nil {
		count++
	}
	if u.Resource != nil {
		count++
	}
	if count != 1 {
		return errors.New("ContentBlock must have exactly one variant set")
	}
	return nil
}

// A streamed item of content
type ContentChunk struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// A single item of content
	Content ContentBlock `json:"content"`
}

// Request to create a new terminal and execute a command.
type CreateTerminalRequest struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// Array of command arguments.
	Args []string `json:"args,omitempty"`
	// The command to execute.
	Command string `json:"command"`
	// Working directory for the command (absolute path).
	Cwd *string `json:"cwd,omitempty"`
	// Environment variables for the command.
	Env []EnvVariable `json:"env,omitempty"`
	// Maximum number of output bytes to retain.
	//
	// When the limit is exceeded, the Client truncates from the beginning of the output
	// to stay within the limit.
	//
	// The Client MUST ensure truncation happens at a character boundary to maintain valid
	// string output, even if this means the retained output is slightly less than the
	// specified limit.
	OutputByteLimit *int `json:"outputByteLimit,omitempty"`
	// The session ID for this request.
	SessionId SessionId `json:"sessionId"`
}

func (v *CreateTerminalRequest) Validate() error {
	if v.Command == "" {
		return fmt.Errorf("command is required")
	}
	return nil
}

// Response containing the ID of the created terminal.
type CreateTerminalResponse struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// The unique identifier for the created terminal.
	TerminalId string `json:"terminalId"`
}

func (v *CreateTerminalResponse) Validate() error {
	if v.TerminalId == "" {
		return fmt.Errorf("terminalId is required")
	}
	return nil
}

// The current mode of the session has changed
//
// See protocol docs: [Session Modes](https://agentclientprotocol.com/protocol/session-modes)
type CurrentModeUpdate struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// The ID of the current mode
	CurrentModeId SessionModeId `json:"currentModeId"`
}

// A diff representing file modifications.
//
// Shows changes to files in a format suitable for display in the client UI.
//
// See protocol docs: [Content](https://agentclientprotocol.com/protocol/tool-calls#content)
type Diff struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// The new content after modification.
	NewText string `json:"newText"`
	// The original content (None for new files).
	OldText *string `json:"oldText,omitempty"`
	// The file path being modified.
	Path string `json:"path"`
}

// The contents of a resource, embedded into a prompt or tool call result.
type EmbeddedResource struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta        map[string]any           `json:"_meta,omitempty"`
	Annotations *Annotations             `json:"annotations,omitempty"`
	Resource    EmbeddedResourceResource `json:"resource"`
}

// Resource content that can be embedded in a message.
type EmbeddedResourceResource struct {
	TextResourceContents *TextResourceContents `json:"-"`
	BlobResourceContents *BlobResourceContents `json:"-"`
}

func (u *EmbeddedResourceResource) UnmarshalJSON(b []byte) error {
	var m map[string]json.RawMessage
	if err := json.Unmarshal(b, &m); err == nil {
		{
			var v TextResourceContents
			var match bool = true
			if _, ok := m["text"]; !ok {
				match = false
			}
			if _, ok := m["uri"]; !ok {
				match = false
			}
			if match {
				if json.Unmarshal(b, &v) != nil {
					return errors.New("invalid variant payload")
				}
				u.TextResourceContents = &v
				return nil
			}
		}
		{
			var v BlobResourceContents
			var match bool = true
			if _, ok := m["blob"]; !ok {
				match = false
			}
			if _, ok := m["uri"]; !ok {
				match = false
			}
			if match {
				if json.Unmarshal(b, &v) != nil {
					return errors.New("invalid variant payload")
				}
				u.BlobResourceContents = &v
				return nil
			}
		}
	} else {
		if _, ok := err.(*json.UnmarshalTypeError); !ok {
			return err
		}
	}
	{
		var v TextResourceContents
		if json.Unmarshal(b, &v) == nil {
			u.TextResourceContents = &v
			return nil
		}
	}
	{
		var v BlobResourceContents
		if json.Unmarshal(b, &v) == nil {
			u.BlobResourceContents = &v
			return nil
		}
	}
	return nil
}
func (u EmbeddedResourceResource) MarshalJSON() ([]byte, error) {
	if u.TextResourceContents != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.TextResourceContents)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	if u.BlobResourceContents != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.BlobResourceContents)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	return []byte{}, nil
}

// An environment variable to set when launching an MCP server.
type EnvVariable struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// The name of the environment variable.
	Name string `json:"name"`
	// The value to set for the environment variable.
	Value string `json:"value"`
}

// JSON-RPC error object.
//
// Represents an error that occurred during method execution, following the
// JSON-RPC 2.0 error object specification with optional additional data.
//
// See protocol docs: [JSON-RPC Error Object](https://www.jsonrpc.org/specification#error_object)
type Error struct {
	// A number indicating the error type that occurred.
	// This must be an integer as defined in the JSON-RPC specification.
	Code ErrorCode `json:"code"`
	// Optional primitive or structured value that contains additional information about the error.
	// This may include debugging information or context-specific details.
	Data any `json:"data,omitempty"`
	// A string providing a short description of the error.
	// The message should be limited to a concise single sentence.
	Message string `json:"message"`
}

// Predefined error codes for common JSON-RPC and ACP-specific errors.
//
// These codes follow the JSON-RPC 2.0 specification for standard errors
// and use the reserved range (-32000 to -32099) for protocol-specific errors.
// **Parse error**: Invalid JSON was received by the server.
// An error occurred on the server while parsing the JSON text.
type ErrorCodeParseError struct{}

// **Invalid request**: The JSON sent is not a valid Request object.
type ErrorCodeInvalidRequest struct{}

// **Method not found**: The method does not exist or is not available.
type ErrorCodeMethodNotFound struct{}

// **Invalid params**: Invalid method parameter(s).
type ErrorCodeInvalidParams struct{}

// **Internal error**: Internal JSON-RPC error.
// Reserved for implementation-defined server errors.
type ErrorCodeInternalError struct{}

// **Authentication required**: Authentication is required before this operation can be performed.
type ErrorCodeAuthenticationRequired struct{}

// **Resource not found**: A given resource, such as a file, was not found.
type ErrorCodeResourceNotFound struct{}

// Other undefined error code.
type ErrorCodeOther struct{}

type ErrorCode struct {
	// **Parse error**: Invalid JSON was received by the server.
	// An error occurred on the server while parsing the JSON text.
	ParseError *ErrorCodeParseError `json:"-"`
	// **Invalid request**: The JSON sent is not a valid Request object.
	InvalidRequest *ErrorCodeInvalidRequest `json:"-"`
	// **Method not found**: The method does not exist or is not available.
	MethodNotFound *ErrorCodeMethodNotFound `json:"-"`
	// **Invalid params**: Invalid method parameter(s).
	InvalidParams *ErrorCodeInvalidParams `json:"-"`
	// **Internal error**: Internal JSON-RPC error.
	// Reserved for implementation-defined server errors.
	InternalError *ErrorCodeInternalError `json:"-"`
	// **Authentication required**: Authentication is required before this operation can be performed.
	AuthenticationRequired *ErrorCodeAuthenticationRequired `json:"-"`
	// **Resource not found**: A given resource, such as a file, was not found.
	ResourceNotFound *ErrorCodeResourceNotFound `json:"-"`
	// Other undefined error code.
	Other *ErrorCodeOther `json:"-"`
}

func (u *ErrorCode) UnmarshalJSON(b []byte) error {
	var m map[string]json.RawMessage
	if err := json.Unmarshal(b, &m); err == nil {
	} else {
		if _, ok := err.(*json.UnmarshalTypeError); !ok {
			return err
		}
	}
	{
		var v ErrorCodeParseError
		if json.Unmarshal(b, &v) == nil {
			u.ParseError = &v
			return nil
		}
	}
	{
		var v ErrorCodeInvalidRequest
		if json.Unmarshal(b, &v) == nil {
			u.InvalidRequest = &v
			return nil
		}
	}
	{
		var v ErrorCodeMethodNotFound
		if json.Unmarshal(b, &v) == nil {
			u.MethodNotFound = &v
			return nil
		}
	}
	{
		var v ErrorCodeInvalidParams
		if json.Unmarshal(b, &v) == nil {
			u.InvalidParams = &v
			return nil
		}
	}
	{
		var v ErrorCodeInternalError
		if json.Unmarshal(b, &v) == nil {
			u.InternalError = &v
			return nil
		}
	}
	{
		var v ErrorCodeAuthenticationRequired
		if json.Unmarshal(b, &v) == nil {
			u.AuthenticationRequired = &v
			return nil
		}
	}
	{
		var v ErrorCodeResourceNotFound
		if json.Unmarshal(b, &v) == nil {
			u.ResourceNotFound = &v
			return nil
		}
	}
	{
		var v ErrorCodeOther
		if json.Unmarshal(b, &v) == nil {
			u.Other = &v
			return nil
		}
	}
	return nil
}
func (u ErrorCode) MarshalJSON() ([]byte, error) {
	if u.ParseError != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.ParseError)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	if u.InvalidRequest != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.InvalidRequest)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	if u.MethodNotFound != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.MethodNotFound)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	if u.InvalidParams != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.InvalidParams)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	if u.InternalError != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.InternalError)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	if u.AuthenticationRequired != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.AuthenticationRequired)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	if u.ResourceNotFound != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.ResourceNotFound)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	if u.Other != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.Other)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	return []byte{}, nil
}

// Allows the Agent to send an arbitrary notification that is not part of the ACP spec.
// Extension notifications provide a way to send one-way messages for custom functionality
// while maintaining protocol compatibility.
//
// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
// ExtNotification is a union or complex schema; represented generically.
type ExtNotification any

// Allows for sending an arbitrary request that is not part of the ACP spec.
// Extension methods provide a way to add custom functionality while maintaining
// protocol compatibility.
//
// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
// ExtRequest is a union or complex schema; represented generically.
type ExtRequest any

// Allows for sending an arbitrary response to an ['ExtRequest'] that is not part of the ACP spec.
// Extension methods provide a way to add custom functionality while maintaining
// protocol compatibility.
//
// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
// ExtResponse is a union or complex schema; represented generically.
type ExtResponse any

// Filesystem capabilities supported by the client.
// File system capabilities that a client may support.
//
// See protocol docs: [FileSystem](https://agentclientprotocol.com/protocol/initialization#filesystem)
type FileSystemCapability struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// Whether the Client supports 'fs/read_text_file' requests.
	//
	// Defaults to false if unset.
	ReadTextFile bool `json:"readTextFile,omitempty"`
	// Whether the Client supports 'fs/write_text_file' requests.
	//
	// Defaults to false if unset.
	WriteTextFile bool `json:"writeTextFile,omitempty"`
}

func (v FileSystemCapability) MarshalJSON() ([]byte, error) {
	type Alias FileSystemCapability
	var a Alias
	a = Alias(v)
	return json.Marshal(a)
}

func (v *FileSystemCapability) UnmarshalJSON(b []byte) error {
	var m map[string]json.RawMessage
	if err := json.Unmarshal(b, &m); err != nil {
		return err
	}
	type Alias FileSystemCapability
	var a Alias
	if err := json.Unmarshal(b, &a); err != nil {
		return err
	}
	{
		_rm, _ok := m["readTextFile"]
		if !_ok || (string(_rm) == "null") {
			json.Unmarshal([]byte("false"), &a.ReadTextFile)
		}
	}
	{
		_rm, _ok := m["writeTextFile"]
		if !_ok || (string(_rm) == "null") {
			json.Unmarshal([]byte("false"), &a.WriteTextFile)
		}
	}
	*v = FileSystemCapability(a)
	return nil
}

// An HTTP header to set when making requests to the MCP server.
type HttpHeader struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// The name of the HTTP header.
	Name string `json:"name"`
	// The value to set for the HTTP header.
	Value string `json:"value"`
}

// An image provided to or from an LLM.
type ImageContent struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta        map[string]any `json:"_meta,omitempty"`
	Annotations *Annotations   `json:"annotations,omitempty"`
	Data        string         `json:"data"`
	MimeType    string         `json:"mimeType"`
	Uri         *string        `json:"uri,omitempty"`
}

// Metadata about the implementation of the client or agent.
// Describes the name and version of an MCP implementation, with an optional
// title for UI representation.
type Implementation struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// Intended for programmatic or logical use, but can be used as a display
	// name fallback if title isn’t present.
	Name string `json:"name"`
	// Intended for UI and end-user contexts — optimized to be human-readable
	// and easily understood.
	//
	// If not provided, the name should be used for display.
	Title *string `json:"title,omitempty"`
	// Version of the implementation. Can be displayed to the user or used
	// for debugging or metrics purposes. (e.g. "1.0.0").
	Version string `json:"version"`
}

// Request parameters for the initialize method.
//
// Sent by the client to establish connection and negotiate capabilities.
//
// See protocol docs: [Initialization](https://agentclientprotocol.com/protocol/initialization)
type InitializeRequest struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// Capabilities supported by the client.
	//
	// Defaults to {"fs":{"readTextFile":false,"writeTextFile":false},"terminal":false} if unset.
	ClientCapabilities ClientCapabilities `json:"clientCapabilities,omitempty"`
	// Information about the Client name and version sent to the Agent.
	//
	// Note: in future versions of the protocol, this will be required.
	ClientInfo *Implementation `json:"clientInfo,omitempty"`
	// The latest protocol version supported by the client.
	ProtocolVersion ProtocolVersion `json:"protocolVersion"`
}

func (v InitializeRequest) MarshalJSON() ([]byte, error) {
	type Alias InitializeRequest
	var a Alias
	a = Alias(v)
	return json.Marshal(a)
}

func (v *InitializeRequest) UnmarshalJSON(b []byte) error {
	var m map[string]json.RawMessage
	if err := json.Unmarshal(b, &m); err != nil {
		return err
	}
	type Alias InitializeRequest
	var a Alias
	if err := json.Unmarshal(b, &a); err != nil {
		return err
	}
	{
		_rm, _ok := m["clientCapabilities"]
		if !_ok || (string(_rm) == "null") {
			json.Unmarshal([]byte("{\"fs\":{\"readTextFile\":false,\"writeTextFile\":false},\"terminal\":false}"), &a.ClientCapabilities)
		}
	}
	*v = InitializeRequest(a)
	return nil
}

func (v *InitializeRequest) Validate() error {
	return nil
}

// Response to the 'initialize' method.
//
// Contains the negotiated protocol version and agent capabilities.
//
// See protocol docs: [Initialization](https://agentclientprotocol.com/protocol/initialization)
type InitializeResponse struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// Capabilities supported by the agent.
	//
	// Defaults to {"loadSession":false,"mcpCapabilities":{"http":false,"sse":false},"promptCapabilities":{"audio":false,"embeddedContext":false,"image":false},"sessionCapabilities":{}} if unset.
	AgentCapabilities AgentCapabilities `json:"agentCapabilities,omitempty"`
	// Information about the Agent name and version sent to the Client.
	//
	// Note: in future versions of the protocol, this will be required.
	AgentInfo *Implementation `json:"agentInfo,omitempty"`
	// Authentication methods supported by the agent.
	//
	// Defaults to [] if unset.
	AuthMethods []AuthMethod `json:"authMethods"`
	// The protocol version the client specified if supported by the agent,
	// or the latest protocol version supported by the agent.
	//
	// The client should disconnect, if it doesn't support this version.
	ProtocolVersion ProtocolVersion `json:"protocolVersion"`
}

func (v InitializeResponse) MarshalJSON() ([]byte, error) {
	type Alias InitializeResponse
	var a Alias
	a = Alias(v)
	if a.AuthMethods == nil {
		json.Unmarshal([]byte("[]"), &a.AuthMethods)
	}
	return json.Marshal(a)
}

func (v *InitializeResponse) UnmarshalJSON(b []byte) error {
	var m map[string]json.RawMessage
	if err := json.Unmarshal(b, &m); err != nil {
		return err
	}
	type Alias InitializeResponse
	var a Alias
	if err := json.Unmarshal(b, &a); err != nil {
		return err
	}
	{
		_rm, _ok := m["agentCapabilities"]
		if !_ok || (string(_rm) == "null") {
			json.Unmarshal([]byte("{\"loadSession\":false,\"mcpCapabilities\":{\"http\":false,\"sse\":false},\"promptCapabilities\":{\"audio\":false,\"embeddedContext\":false,\"image\":false},\"sessionCapabilities\":{}}"), &a.AgentCapabilities)
		}
	}
	{
		_rm, _ok := m["authMethods"]
		if !_ok || (string(_rm) == "null") {
			json.Unmarshal([]byte("[]"), &a.AuthMethods)
		}
	}
	*v = InitializeResponse(a)
	return nil
}

func (v *InitializeResponse) Validate() error {
	return nil
}

// Request to kill a terminal command without releasing the terminal.
type KillTerminalCommandRequest struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// The session ID for this request.
	SessionId SessionId `json:"sessionId"`
	// The ID of the terminal to kill.
	TerminalId string `json:"terminalId"`
}

func (v *KillTerminalCommandRequest) Validate() error {
	if v.TerminalId == "" {
		return fmt.Errorf("terminalId is required")
	}
	return nil
}

// Response to terminal/kill command method
type KillTerminalCommandResponse struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
}

func (v *KillTerminalCommandResponse) Validate() error {
	return nil
}

// Request parameters for loading an existing session.
//
// Only available if the Agent supports the 'loadSession' capability.
//
// See protocol docs: [Loading Sessions](https://agentclientprotocol.com/protocol/session-setup#loading-sessions)
type LoadSessionRequest struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// The working directory for this session.
	Cwd string `json:"cwd"`
	// List of MCP servers to connect to for this session.
	McpServers []McpServer `json:"mcpServers"`
	// The ID of the session to load.
	SessionId SessionId `json:"sessionId"`
}

func (v *LoadSessionRequest) Validate() error {
	if v.Cwd == "" {
		return fmt.Errorf("cwd is required")
	}
	if v.McpServers == nil {
		return fmt.Errorf("mcpServers is required")
	}
	return nil
}

// Response from loading an existing session.
type LoadSessionResponse struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// Initial mode state if supported by the Agent
	//
	// See protocol docs: [Session Modes](https://agentclientprotocol.com/protocol/session-modes)
	Modes *SessionModeState `json:"modes,omitempty"`
}

func (v *LoadSessionResponse) Validate() error {
	return nil
}

// MCP capabilities supported by the agent
type McpCapabilities struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// Agent supports ['McpServer::Http'].
	//
	// Defaults to false if unset.
	Http bool `json:"http,omitempty"`
	// Agent supports ['McpServer::Sse'].
	//
	// Defaults to false if unset.
	Sse bool `json:"sse,omitempty"`
}

func (v McpCapabilities) MarshalJSON() ([]byte, error) {
	type Alias McpCapabilities
	var a Alias
	a = Alias(v)
	return json.Marshal(a)
}

func (v *McpCapabilities) UnmarshalJSON(b []byte) error {
	var m map[string]json.RawMessage
	if err := json.Unmarshal(b, &m); err != nil {
		return err
	}
	type Alias McpCapabilities
	var a Alias
	if err := json.Unmarshal(b, &a); err != nil {
		return err
	}
	{
		_rm, _ok := m["http"]
		if !_ok || (string(_rm) == "null") {
			json.Unmarshal([]byte("false"), &a.Http)
		}
	}
	{
		_rm, _ok := m["sse"]
		if !_ok || (string(_rm) == "null") {
			json.Unmarshal([]byte("false"), &a.Sse)
		}
	}
	*v = McpCapabilities(a)
	return nil
}

// Configuration for connecting to an MCP (Model Context Protocol) server.
//
// MCP servers provide tools and context that the agent can use when
// processing prompts.
//
// See protocol docs: [MCP Servers](https://agentclientprotocol.com/protocol/session-setup#mcp-servers)
// HTTP transport configuration
//
// Only available when the Agent capabilities indicate 'mcp_capabilities.http' is 'true'.
type McpServerHttpInline struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// HTTP headers to set when making requests to the MCP server.
	Headers []HttpHeader `json:"headers"`
	// Human-readable name identifying this MCP server.
	Name string `json:"name"`
	Type string `json:"type"`
	// URL to the MCP server.
	Url string `json:"url"`
}

// SSE transport configuration
//
// Only available when the Agent capabilities indicate 'mcp_capabilities.sse' is 'true'.
type McpServerSseInline struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// HTTP headers to set when making requests to the MCP server.
	Headers []HttpHeader `json:"headers"`
	// Human-readable name identifying this MCP server.
	Name string `json:"name"`
	Type string `json:"type"`
	// URL to the MCP server.
	Url string `json:"url"`
}

type McpServer struct {
	// HTTP transport configuration
	//
	// Only available when the Agent capabilities indicate 'mcp_capabilities.http' is 'true'.
	Http *McpServerHttpInline `json:"-"`
	// SSE transport configuration
	//
	// Only available when the Agent capabilities indicate 'mcp_capabilities.sse' is 'true'.
	Sse *McpServerSseInline `json:"-"`
	// Stdio transport configuration
	//
	// All Agents MUST support this transport.
	Stdio *McpServerStdio `json:"-"`
}

func (u *McpServer) UnmarshalJSON(b []byte) error {
	var m map[string]json.RawMessage
	if err := json.Unmarshal(b, &m); err == nil {
		{
			var disc string
			if v, ok := m["type"]; ok {
				json.Unmarshal(v, &disc)
			}
			switch disc {
			case "http":
				var v McpServerHttpInline
				if json.Unmarshal(b, &v) != nil {
					return errors.New("invalid variant payload")
				}
				u.Http = &v
				return nil
			case "sse":
				var v McpServerSseInline
				if json.Unmarshal(b, &v) != nil {
					return errors.New("invalid variant payload")
				}
				u.Sse = &v
				return nil
			}
		}
		{
			var v McpServerHttpInline
			var match bool = true
			if _, ok := m["type"]; !ok {
				match = false
			}
			if _, ok := m["name"]; !ok {
				match = false
			}
			if _, ok := m["url"]; !ok {
				match = false
			}
			if _, ok := m["headers"]; !ok {
				match = false
			}
			if match {
				if json.Unmarshal(b, &v) != nil {
					return errors.New("invalid variant payload")
				}
				u.Http = &v
				return nil
			}
		}
		{
			var v McpServerSseInline
			var match bool = true
			if _, ok := m["type"]; !ok {
				match = false
			}
			if _, ok := m["name"]; !ok {
				match = false
			}
			if _, ok := m["url"]; !ok {
				match = false
			}
			if _, ok := m["headers"]; !ok {
				match = false
			}
			if match {
				if json.Unmarshal(b, &v) != nil {
					return errors.New("invalid variant payload")
				}
				u.Sse = &v
				return nil
			}
		}
		{
			var v McpServerStdio
			var match bool = true
			if _, ok := m["name"]; !ok {
				match = false
			}
			if _, ok := m["command"]; !ok {
				match = false
			}
			if _, ok := m["args"]; !ok {
				match = false
			}
			if _, ok := m["env"]; !ok {
				match = false
			}
			if match {
				if json.Unmarshal(b, &v) != nil {
					return errors.New("invalid variant payload")
				}
				u.Stdio = &v
				return nil
			}
		}
	} else {
		if _, ok := err.(*json.UnmarshalTypeError); !ok {
			return err
		}
	}
	{
		var v McpServerHttpInline
		if json.Unmarshal(b, &v) == nil {
			u.Http = &v
			return nil
		}
	}
	{
		var v McpServerSseInline
		if json.Unmarshal(b, &v) == nil {
			u.Sse = &v
			return nil
		}
	}
	{
		var v McpServerStdio
		if json.Unmarshal(b, &v) == nil {
			u.Stdio = &v
			return nil
		}
	}
	return nil
}
func (u McpServer) MarshalJSON() ([]byte, error) {
	if u.Http != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.Http)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		m["type"] = "http"
		return json.Marshal(m)
	}
	if u.Sse != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.Sse)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		m["type"] = "sse"
		return json.Marshal(m)
	}
	if u.Stdio != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.Stdio)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	return []byte{}, nil
}

// HTTP transport configuration for MCP.
type McpServerHttp struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// HTTP headers to set when making requests to the MCP server.
	Headers []HttpHeader `json:"headers"`
	// Human-readable name identifying this MCP server.
	Name string `json:"name"`
	// URL to the MCP server.
	Url string `json:"url"`
}

// SSE transport configuration for MCP.
type McpServerSse struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// HTTP headers to set when making requests to the MCP server.
	Headers []HttpHeader `json:"headers"`
	// Human-readable name identifying this MCP server.
	Name string `json:"name"`
	// URL to the MCP server.
	Url string `json:"url"`
}

// Stdio transport configuration for MCP.
type McpServerStdio struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// Command-line arguments to pass to the MCP server.
	Args []string `json:"args"`
	// Path to the MCP server executable.
	Command string `json:"command"`
	// Environment variables to set when launching the MCP server.
	Env []EnvVariable `json:"env"`
	// Human-readable name identifying this MCP server.
	Name string `json:"name"`
}

// Request parameters for creating a new session.
//
// See protocol docs: [Creating a Session](https://agentclientprotocol.com/protocol/session-setup#creating-a-session)
type NewSessionRequest struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// The working directory for this session. Must be an absolute path.
	Cwd string `json:"cwd"`
	// List of MCP (Model Context Protocol) servers the agent should connect to.
	McpServers []McpServer `json:"mcpServers"`
}

func (v *NewSessionRequest) Validate() error {
	if v.Cwd == "" {
		return fmt.Errorf("cwd is required")
	}
	if v.McpServers == nil {
		return fmt.Errorf("mcpServers is required")
	}
	return nil
}

// Response from creating a new session.
//
// See protocol docs: [Creating a Session](https://agentclientprotocol.com/protocol/session-setup#creating-a-session)
type NewSessionResponse struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// Initial mode state if supported by the Agent
	//
	// See protocol docs: [Session Modes](https://agentclientprotocol.com/protocol/session-modes)
	Modes *SessionModeState `json:"modes,omitempty"`
	// Unique identifier for the created session.
	//
	// Used in all subsequent requests for this conversation.
	SessionId SessionId `json:"sessionId"`
}

func (v *NewSessionResponse) Validate() error {
	return nil
}

// An option presented to the user when requesting permission.
type PermissionOption struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// Hint about the nature of this permission option.
	Kind PermissionOptionKind `json:"kind"`
	// Human-readable label to display to the user.
	Name string `json:"name"`
	// Unique identifier for this permission option.
	OptionId PermissionOptionId `json:"optionId"`
}

// Unique identifier for a permission option.
type PermissionOptionId string

// The type of permission option being presented to the user.
//
// Helps clients choose appropriate icons and UI treatment.
type PermissionOptionKind string

const (
	PermissionOptionKindAllowOnce    PermissionOptionKind = "allow_once"
	PermissionOptionKindAllowAlways  PermissionOptionKind = "allow_always"
	PermissionOptionKindRejectOnce   PermissionOptionKind = "reject_once"
	PermissionOptionKindRejectAlways PermissionOptionKind = "reject_always"
)

// An execution plan for accomplishing complex tasks.
//
// Plans consist of multiple entries representing individual tasks or goals.
// Agents report plans to clients to provide visibility into their execution strategy.
// Plans can evolve during execution as the agent discovers new requirements or completes tasks.
//
// See protocol docs: [Agent Plan](https://agentclientprotocol.com/protocol/agent-plan)
type Plan struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// The list of tasks to be accomplished.
	//
	// When updating a plan, the agent must send a complete list of all entries
	// with their current status. The client replaces the entire plan with each update.
	Entries []PlanEntry `json:"entries"`
}

// A single entry in the execution plan.
//
// Represents a task or goal that the assistant intends to accomplish
// as part of fulfilling the user's request.
// See protocol docs: [Plan Entries](https://agentclientprotocol.com/protocol/agent-plan#plan-entries)
type PlanEntry struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// Human-readable description of what this task aims to accomplish.
	Content string `json:"content"`
	// The relative importance of this task.
	// Used to indicate which tasks are most critical to the overall goal.
	Priority PlanEntryPriority `json:"priority"`
	// Current execution status of this task.
	Status PlanEntryStatus `json:"status"`
}

// Priority levels for plan entries.
//
// Used to indicate the relative importance or urgency of different
// tasks in the execution plan.
// See protocol docs: [Plan Entries](https://agentclientprotocol.com/protocol/agent-plan#plan-entries)
type PlanEntryPriority string

const (
	PlanEntryPriorityHigh   PlanEntryPriority = "high"
	PlanEntryPriorityMedium PlanEntryPriority = "medium"
	PlanEntryPriorityLow    PlanEntryPriority = "low"
)

// Status of a plan entry in the execution flow.
//
// Tracks the lifecycle of each task from planning through completion.
// See protocol docs: [Plan Entries](https://agentclientprotocol.com/protocol/agent-plan#plan-entries)
type PlanEntryStatus string

const (
	PlanEntryStatusPending    PlanEntryStatus = "pending"
	PlanEntryStatusInProgress PlanEntryStatus = "in_progress"
	PlanEntryStatusCompleted  PlanEntryStatus = "completed"
)

// Prompt capabilities supported by the agent in 'session/prompt' requests.
//
// Baseline agent functionality requires support for ['ContentBlock::Text']
// and ['ContentBlock::ResourceLink'] in prompt requests.
//
// Other variants must be explicitly opted in to.
// Capabilities for different types of content in prompt requests.
//
// Indicates which content types beyond the baseline (text and resource links)
// the agent can process.
//
// See protocol docs: [Prompt Capabilities](https://agentclientprotocol.com/protocol/initialization#prompt-capabilities)
type PromptCapabilities struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// Agent supports ['ContentBlock::Audio'].
	//
	// Defaults to false if unset.
	Audio bool `json:"audio,omitempty"`
	// Agent supports embedded context in 'session/prompt' requests.
	//
	// When enabled, the Client is allowed to include ['ContentBlock::Resource']
	// in prompt requests for pieces of context that are referenced in the message.
	//
	// Defaults to false if unset.
	EmbeddedContext bool `json:"embeddedContext,omitempty"`
	// Agent supports ['ContentBlock::Image'].
	//
	// Defaults to false if unset.
	Image bool `json:"image,omitempty"`
}

func (v PromptCapabilities) MarshalJSON() ([]byte, error) {
	type Alias PromptCapabilities
	var a Alias
	a = Alias(v)
	return json.Marshal(a)
}

func (v *PromptCapabilities) UnmarshalJSON(b []byte) error {
	var m map[string]json.RawMessage
	if err := json.Unmarshal(b, &m); err != nil {
		return err
	}
	type Alias PromptCapabilities
	var a Alias
	if err := json.Unmarshal(b, &a); err != nil {
		return err
	}
	{
		_rm, _ok := m["audio"]
		if !_ok || (string(_rm) == "null") {
			json.Unmarshal([]byte("false"), &a.Audio)
		}
	}
	{
		_rm, _ok := m["embeddedContext"]
		if !_ok || (string(_rm) == "null") {
			json.Unmarshal([]byte("false"), &a.EmbeddedContext)
		}
	}
	{
		_rm, _ok := m["image"]
		if !_ok || (string(_rm) == "null") {
			json.Unmarshal([]byte("false"), &a.Image)
		}
	}
	*v = PromptCapabilities(a)
	return nil
}

// Request parameters for sending a user prompt to the agent.
//
// Contains the user's message and any additional context.
//
// See protocol docs: [User Message](https://agentclientprotocol.com/protocol/prompt-turn#1-user-message)
type PromptRequest struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// The blocks of content that compose the user's message.
	//
	// As a baseline, the Agent MUST support ['ContentBlock::Text'] and ['ContentBlock::ResourceLink'],
	// while other variants are optionally enabled via ['PromptCapabilities'].
	//
	// The Client MUST adapt its interface according to ['PromptCapabilities'].
	//
	// The client MAY include referenced pieces of context as either
	// ['ContentBlock::Resource'] or ['ContentBlock::ResourceLink'].
	//
	// When available, ['ContentBlock::Resource'] is preferred
	// as it avoids extra round-trips and allows the message to include
	// pieces of context from sources the agent may not have access to.
	Prompt []ContentBlock `json:"prompt"`
	// The ID of the session to send this user message to
	SessionId SessionId `json:"sessionId"`
}

func (v *PromptRequest) Validate() error {
	if v.Prompt == nil {
		return fmt.Errorf("prompt is required")
	}
	return nil
}

// Response from processing a user prompt.
//
// See protocol docs: [Check for Completion](https://agentclientprotocol.com/protocol/prompt-turn#4-check-for-completion)
type PromptResponse struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// Indicates why the agent stopped processing the turn.
	StopReason StopReason `json:"stopReason"`
}

func (v *PromptResponse) Validate() error {
	return nil
}

// Protocol version identifier.
//
// This version is only bumped for breaking changes.
// Non-breaking changes should be introduced via capabilities.
type ProtocolVersion int

// Request to read content from a text file.
//
// Only available if the client supports the 'fs.readTextFile' capability.
type ReadTextFileRequest struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// Maximum number of lines to read.
	Limit *int `json:"limit,omitempty"`
	// Line number to start reading from (1-based).
	Line *int `json:"line,omitempty"`
	// Absolute path to the file to read.
	Path string `json:"path"`
	// The session ID for this request.
	SessionId SessionId `json:"sessionId"`
}

func (v *ReadTextFileRequest) Validate() error {
	if v.Path == "" {
		return fmt.Errorf("path is required")
	}
	return nil
}

// Response containing the contents of a text file.
type ReadTextFileResponse struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta    map[string]any `json:"_meta,omitempty"`
	Content string         `json:"content"`
}

func (v *ReadTextFileResponse) Validate() error {
	if v.Content == "" {
		return fmt.Errorf("content is required")
	}
	return nil
}

// Request to release a terminal and free its resources.
type ReleaseTerminalRequest struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// The session ID for this request.
	SessionId SessionId `json:"sessionId"`
	// The ID of the terminal to release.
	TerminalId string `json:"terminalId"`
}

func (v *ReleaseTerminalRequest) Validate() error {
	if v.TerminalId == "" {
		return fmt.Errorf("terminalId is required")
	}
	return nil
}

// Response to terminal/release method
type ReleaseTerminalResponse struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
}

func (v *ReleaseTerminalResponse) Validate() error {
	return nil
}

// JSON RPC Request Id
//
// An identifier established by the Client that MUST contain a String, Number, or NULL value if included. If it is not included it is assumed to be a notification. The value SHOULD normally not be Null [1] and Numbers SHOULD NOT contain fractional parts [2]
//
// The Server MUST reply with the same value in the Response object if included. This member is used to correlate the context between the two objects.
//
// [1] The use of Null as a value for the id member in a Request object is discouraged, because this specification uses a value of Null for Responses with an unknown id. Also, because JSON-RPC 1.0 uses an id value of Null for Notifications this could cause confusion in handling.
//
// [2] Fractional parts may be problematic, since many decimal fractions cannot be represented exactly as binary fractions.
type RequestIdNull struct{}

type RequestIdNumber struct{}

type RequestIdStr struct{}

type RequestId struct {
	Null   *RequestIdNull   `json:"-"`
	Number *RequestIdNumber `json:"-"`
	Str    *RequestIdStr    `json:"-"`
}

func (u *RequestId) UnmarshalJSON(b []byte) error {
	if string(b) == "null" {
		var v RequestIdNull
		u.Null = &v
		return nil
	}
	var m map[string]json.RawMessage
	if err := json.Unmarshal(b, &m); err == nil {
	} else {
		if _, ok := err.(*json.UnmarshalTypeError); !ok {
			return err
		}
	}
	{
		var v RequestIdNull
		if json.Unmarshal(b, &v) == nil {
			u.Null = &v
			return nil
		}
	}
	{
		var v RequestIdNumber
		if json.Unmarshal(b, &v) == nil {
			u.Number = &v
			return nil
		}
	}
	{
		var v RequestIdStr
		if json.Unmarshal(b, &v) == nil {
			u.Str = &v
			return nil
		}
	}
	return nil
}
func (u RequestId) MarshalJSON() ([]byte, error) {
	if u.Null != nil {
		return json.Marshal(nil)
	}
	if u.Number != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.Number)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	if u.Str != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.Str)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	return []byte{}, nil
}

// The outcome of a permission request.
// The prompt turn was cancelled before the user responded.
//
// When a client sends a 'session/cancel' notification to cancel an ongoing
// prompt turn, it MUST respond to all pending 'session/request_permission'
// requests with this 'Cancelled' outcome.
//
// See protocol docs: [Cancellation](https://agentclientprotocol.com/protocol/prompt-turn#cancellation)
type RequestPermissionOutcomeCancelled struct {
	Outcome string `json:"outcome"`
}

// The user selected one of the provided options.
type RequestPermissionOutcomeSelected struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// The ID of the option the user selected.
	OptionId PermissionOptionId `json:"optionId"`
	Outcome  string             `json:"outcome"`
}

type RequestPermissionOutcome struct {
	// The prompt turn was cancelled before the user responded.
	//
	// When a client sends a 'session/cancel' notification to cancel an ongoing
	// prompt turn, it MUST respond to all pending 'session/request_permission'
	// requests with this 'Cancelled' outcome.
	//
	// See protocol docs: [Cancellation](https://agentclientprotocol.com/protocol/prompt-turn#cancellation)
	Cancelled *RequestPermissionOutcomeCancelled `json:"-"`
	// The user selected one of the provided options.
	Selected *RequestPermissionOutcomeSelected `json:"-"`
}

func (u *RequestPermissionOutcome) UnmarshalJSON(b []byte) error {
	var m map[string]json.RawMessage
	if err := json.Unmarshal(b, &m); err == nil {
		{
			var disc string
			if v, ok := m["outcome"]; ok {
				json.Unmarshal(v, &disc)
			}
			switch disc {
			case "cancelled":
				var v RequestPermissionOutcomeCancelled
				if json.Unmarshal(b, &v) != nil {
					return errors.New("invalid variant payload")
				}
				u.Cancelled = &v
				return nil
			case "selected":
				var v RequestPermissionOutcomeSelected
				if json.Unmarshal(b, &v) != nil {
					return errors.New("invalid variant payload")
				}
				u.Selected = &v
				return nil
			}
		}
		{
			var v RequestPermissionOutcomeCancelled
			var match bool = true
			if _, ok := m["outcome"]; !ok {
				match = false
			}
			if match {
				if json.Unmarshal(b, &v) != nil {
					return errors.New("invalid variant payload")
				}
				u.Cancelled = &v
				return nil
			}
		}
		{
			var v RequestPermissionOutcomeSelected
			var match bool = true
			if _, ok := m["outcome"]; !ok {
				match = false
			}
			if _, ok := m["optionId"]; !ok {
				match = false
			}
			if match {
				if json.Unmarshal(b, &v) != nil {
					return errors.New("invalid variant payload")
				}
				u.Selected = &v
				return nil
			}
		}
	} else {
		if _, ok := err.(*json.UnmarshalTypeError); !ok {
			return err
		}
	}
	{
		var v RequestPermissionOutcomeCancelled
		if json.Unmarshal(b, &v) == nil {
			u.Cancelled = &v
			return nil
		}
	}
	{
		var v RequestPermissionOutcomeSelected
		if json.Unmarshal(b, &v) == nil {
			u.Selected = &v
			return nil
		}
	}
	return nil
}
func (u RequestPermissionOutcome) MarshalJSON() ([]byte, error) {
	if u.Cancelled != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.Cancelled)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		m["outcome"] = "cancelled"
		return json.Marshal(m)
	}
	if u.Selected != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.Selected)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		m["outcome"] = "selected"
		return json.Marshal(m)
	}
	return []byte{}, nil
}

func (u *RequestPermissionOutcome) Validate() error {
	var count int
	if u.Cancelled != nil {
		count++
	}
	if u.Selected != nil {
		count++
	}
	if count != 1 {
		return errors.New("RequestPermissionOutcome must have exactly one variant set")
	}
	return nil
}

// Request for user permission to execute a tool call.
//
// Sent when the agent needs authorization before performing a sensitive operation.
//
// See protocol docs: [Requesting Permission](https://agentclientprotocol.com/protocol/tool-calls#requesting-permission)
type RequestPermissionRequest struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// Available permission options for the user to choose from.
	Options []PermissionOption `json:"options"`
	// The session ID for this request.
	SessionId SessionId `json:"sessionId"`
	// Details about the tool call requiring permission.
	ToolCall ToolCallUpdate `json:"toolCall"`
}

func (v *RequestPermissionRequest) Validate() error {
	if v.Options == nil {
		return fmt.Errorf("options is required")
	}
	return nil
}

// Response to a permission request.
type RequestPermissionResponse struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// The user's decision on the permission request.
	Outcome RequestPermissionOutcome `json:"outcome"`
}

func (v *RequestPermissionResponse) Validate() error {
	return nil
}

// A resource that the server is capable of reading, included in a prompt or tool call result.
type ResourceLink struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta        map[string]any `json:"_meta,omitempty"`
	Annotations *Annotations   `json:"annotations,omitempty"`
	Description *string        `json:"description,omitempty"`
	MimeType    *string        `json:"mimeType,omitempty"`
	Name        string         `json:"name"`
	Size        *int           `json:"size,omitempty"`
	Title       *string        `json:"title,omitempty"`
	Uri         string         `json:"uri"`
}

// The sender or recipient of messages and data in a conversation.
type Role string

const (
	RoleAssistant Role = "assistant"
	RoleUser      Role = "user"
)

// The user selected one of the provided options.
type SelectedPermissionOutcome struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// The ID of the option the user selected.
	OptionId PermissionOptionId `json:"optionId"`
}

// Session capabilities supported by the agent.
//
// As a baseline, all Agents **MUST** support 'session/new', 'session/prompt', 'session/cancel', and 'session/update'.
//
// Optionally, they **MAY** support other session methods and notifications by specifying additional capabilities.
//
// Note: 'session/load' is still handled by the top-level 'load_session' capability. This will be unified in future versions of the protocol.
//
// See protocol docs: [Session Capabilities](https://agentclientprotocol.com/protocol/initialization#session-capabilities)
type SessionCapabilities struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
}

// A unique identifier for a conversation session between a client and agent.
//
// Sessions maintain their own context, conversation history, and state,
// allowing multiple independent interactions with the same agent.
//
// See protocol docs: [Session ID](https://agentclientprotocol.com/protocol/session-setup#session-id)
type SessionId string

// A mode the agent can operate in.
//
// See protocol docs: [Session Modes](https://agentclientprotocol.com/protocol/session-modes)
type SessionMode struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta        map[string]any `json:"_meta,omitempty"`
	Description *string        `json:"description,omitempty"`
	Id          SessionModeId  `json:"id"`
	Name        string         `json:"name"`
}

// Unique identifier for a Session Mode.
type SessionModeId string

// The set of modes and the one currently active.
type SessionModeState struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// The set of modes that the Agent can operate in
	AvailableModes []SessionMode `json:"availableModes"`
	// The current mode the Agent is in.
	CurrentModeId SessionModeId `json:"currentModeId"`
}

// Notification containing a session update from the agent.
//
// Used to stream real-time progress and results during prompt processing.
//
// See protocol docs: [Agent Reports Output](https://agentclientprotocol.com/protocol/prompt-turn#3-agent-reports-output)
type SessionNotification struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// The ID of the session this update pertains to.
	SessionId SessionId `json:"sessionId"`
	// The actual update content.
	Update SessionUpdate `json:"update"`
}

func (v *SessionNotification) Validate() error {
	return nil
}

// Different types of updates that can be sent during session processing.
//
// These updates provide real-time feedback about the agent's progress.
//
// See protocol docs: [Agent Reports Output](https://agentclientprotocol.com/protocol/prompt-turn#3-agent-reports-output)
// A chunk of the user's message being streamed.
type SessionUpdateUserMessageChunk struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// A single item of content
	Content       ContentBlock `json:"content"`
	SessionUpdate string       `json:"sessionUpdate"`
}

// A chunk of the agent's response being streamed.
type SessionUpdateAgentMessageChunk struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// A single item of content
	Content       ContentBlock `json:"content"`
	SessionUpdate string       `json:"sessionUpdate"`
}

// A chunk of the agent's internal reasoning being streamed.
type SessionUpdateAgentThoughtChunk struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// A single item of content
	Content       ContentBlock `json:"content"`
	SessionUpdate string       `json:"sessionUpdate"`
}

// Notification that a new tool call has been initiated.
type SessionUpdateToolCall struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// Content produced by the tool call.
	Content []ToolCallContent `json:"content,omitempty"`
	// The category of tool being invoked.
	// Helps clients choose appropriate icons and UI treatment.
	Kind ToolKind `json:"kind,omitempty"`
	// File locations affected by this tool call.
	// Enables "follow-along" features in clients.
	Locations []ToolCallLocation `json:"locations,omitempty"`
	// Raw input parameters sent to the tool.
	RawInput any `json:"rawInput,omitempty"`
	// Raw output returned by the tool.
	RawOutput     any    `json:"rawOutput,omitempty"`
	SessionUpdate string `json:"sessionUpdate"`
	// Current execution status of the tool call.
	Status ToolCallStatus `json:"status,omitempty"`
	// Human-readable title describing what the tool is doing.
	Title string `json:"title"`
	// Unique identifier for this tool call within the session.
	ToolCallId ToolCallId `json:"toolCallId"`
}

// Update on the status or results of a tool call.
type SessionToolCallUpdate struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// Replace the content collection.
	Content []ToolCallContent `json:"content,omitempty"`
	// Update the tool kind.
	Kind *ToolKind `json:"kind,omitempty"`
	// Replace the locations collection.
	Locations []ToolCallLocation `json:"locations,omitempty"`
	// Update the raw input.
	RawInput any `json:"rawInput,omitempty"`
	// Update the raw output.
	RawOutput     any    `json:"rawOutput,omitempty"`
	SessionUpdate string `json:"sessionUpdate"`
	// Update the execution status.
	Status *ToolCallStatus `json:"status,omitempty"`
	// Update the human-readable title.
	Title *string `json:"title,omitempty"`
	// The ID of the tool call being updated.
	ToolCallId ToolCallId `json:"toolCallId"`
}

// The agent's execution plan for complex tasks.
// See protocol docs: [Agent Plan](https://agentclientprotocol.com/protocol/agent-plan)
type SessionUpdatePlan struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// The list of tasks to be accomplished.
	//
	// When updating a plan, the agent must send a complete list of all entries
	// with their current status. The client replaces the entire plan with each update.
	Entries       []PlanEntry `json:"entries"`
	SessionUpdate string      `json:"sessionUpdate"`
}

// Available commands are ready or have changed
type SessionAvailableCommandsUpdate struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// Commands the agent can execute
	AvailableCommands []AvailableCommand `json:"availableCommands"`
	SessionUpdate     string             `json:"sessionUpdate"`
}

// The current mode of the session has changed
//
// See protocol docs: [Session Modes](https://agentclientprotocol.com/protocol/session-modes)
type SessionCurrentModeUpdate struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// The ID of the current mode
	CurrentModeId SessionModeId `json:"currentModeId"`
	SessionUpdate string        `json:"sessionUpdate"`
}

type SessionUpdate struct {
	// A chunk of the user's message being streamed.
	UserMessageChunk *SessionUpdateUserMessageChunk `json:"-"`
	// A chunk of the agent's response being streamed.
	AgentMessageChunk *SessionUpdateAgentMessageChunk `json:"-"`
	// A chunk of the agent's internal reasoning being streamed.
	AgentThoughtChunk *SessionUpdateAgentThoughtChunk `json:"-"`
	// Notification that a new tool call has been initiated.
	ToolCall *SessionUpdateToolCall `json:"-"`
	// Update on the status or results of a tool call.
	ToolCallUpdate *SessionToolCallUpdate `json:"-"`
	// The agent's execution plan for complex tasks.
	// See protocol docs: [Agent Plan](https://agentclientprotocol.com/protocol/agent-plan)
	Plan *SessionUpdatePlan `json:"-"`
	// Available commands are ready or have changed
	AvailableCommandsUpdate *SessionAvailableCommandsUpdate `json:"-"`
	// The current mode of the session has changed
	//
	// See protocol docs: [Session Modes](https://agentclientprotocol.com/protocol/session-modes)
	CurrentModeUpdate *SessionCurrentModeUpdate `json:"-"`
}

func (u *SessionUpdate) UnmarshalJSON(b []byte) error {
	var m map[string]json.RawMessage
	if err := json.Unmarshal(b, &m); err == nil {
		{
			var disc string
			if v, ok := m["sessionUpdate"]; ok {
				json.Unmarshal(v, &disc)
			}
			switch disc {
			case "user_message_chunk":
				var v SessionUpdateUserMessageChunk
				if json.Unmarshal(b, &v) != nil {
					return errors.New("invalid variant payload")
				}
				u.UserMessageChunk = &v
				return nil
			case "agent_message_chunk":
				var v SessionUpdateAgentMessageChunk
				if json.Unmarshal(b, &v) != nil {
					return errors.New("invalid variant payload")
				}
				u.AgentMessageChunk = &v
				return nil
			case "agent_thought_chunk":
				var v SessionUpdateAgentThoughtChunk
				if json.Unmarshal(b, &v) != nil {
					return errors.New("invalid variant payload")
				}
				u.AgentThoughtChunk = &v
				return nil
			case "tool_call":
				var v SessionUpdateToolCall
				if json.Unmarshal(b, &v) != nil {
					return errors.New("invalid variant payload")
				}
				u.ToolCall = &v
				return nil
			case "tool_call_update":
				var v SessionToolCallUpdate
				if json.Unmarshal(b, &v) != nil {
					return errors.New("invalid variant payload")
				}
				u.ToolCallUpdate = &v
				return nil
			case "plan":
				var v SessionUpdatePlan
				if json.Unmarshal(b, &v) != nil {
					return errors.New("invalid variant payload")
				}
				u.Plan = &v
				return nil
			case "available_commands_update":
				var v SessionAvailableCommandsUpdate
				if json.Unmarshal(b, &v) != nil {
					return errors.New("invalid variant payload")
				}
				u.AvailableCommandsUpdate = &v
				return nil
			case "current_mode_update":
				var v SessionCurrentModeUpdate
				if json.Unmarshal(b, &v) != nil {
					return errors.New("invalid variant payload")
				}
				u.CurrentModeUpdate = &v
				return nil
			}
		}
		{
			var v SessionUpdateUserMessageChunk
			var match bool = true
			if _, ok := m["sessionUpdate"]; !ok {
				match = false
			}
			if _, ok := m["content"]; !ok {
				match = false
			}
			if match {
				if json.Unmarshal(b, &v) != nil {
					return errors.New("invalid variant payload")
				}
				u.UserMessageChunk = &v
				return nil
			}
		}
		{
			var v SessionUpdateAgentMessageChunk
			var match bool = true
			if _, ok := m["sessionUpdate"]; !ok {
				match = false
			}
			if _, ok := m["content"]; !ok {
				match = false
			}
			if match {
				if json.Unmarshal(b, &v) != nil {
					return errors.New("invalid variant payload")
				}
				u.AgentMessageChunk = &v
				return nil
			}
		}
		{
			var v SessionUpdateAgentThoughtChunk
			var match bool = true
			if _, ok := m["sessionUpdate"]; !ok {
				match = false
			}
			if _, ok := m["content"]; !ok {
				match = false
			}
			if match {
				if json.Unmarshal(b, &v) != nil {
					return errors.New("invalid variant payload")
				}
				u.AgentThoughtChunk = &v
				return nil
			}
		}
		{
			var v SessionUpdateToolCall
			var match bool = true
			if _, ok := m["sessionUpdate"]; !ok {
				match = false
			}
			if _, ok := m["toolCallId"]; !ok {
				match = false
			}
			if _, ok := m["title"]; !ok {
				match = false
			}
			if match {
				if json.Unmarshal(b, &v) != nil {
					return errors.New("invalid variant payload")
				}
				u.ToolCall = &v
				return nil
			}
		}
		{
			var v SessionToolCallUpdate
			var match bool = true
			if _, ok := m["sessionUpdate"]; !ok {
				match = false
			}
			if _, ok := m["toolCallId"]; !ok {
				match = false
			}
			if match {
				if json.Unmarshal(b, &v) != nil {
					return errors.New("invalid variant payload")
				}
				u.ToolCallUpdate = &v
				return nil
			}
		}
		{
			var v SessionUpdatePlan
			var match bool = true
			if _, ok := m["sessionUpdate"]; !ok {
				match = false
			}
			if _, ok := m["entries"]; !ok {
				match = false
			}
			if match {
				if json.Unmarshal(b, &v) != nil {
					return errors.New("invalid variant payload")
				}
				u.Plan = &v
				return nil
			}
		}
		{
			var v SessionAvailableCommandsUpdate
			var match bool = true
			if _, ok := m["sessionUpdate"]; !ok {
				match = false
			}
			if _, ok := m["availableCommands"]; !ok {
				match = false
			}
			if match {
				if json.Unmarshal(b, &v) != nil {
					return errors.New("invalid variant payload")
				}
				u.AvailableCommandsUpdate = &v
				return nil
			}
		}
		{
			var v SessionCurrentModeUpdate
			var match bool = true
			if _, ok := m["sessionUpdate"]; !ok {
				match = false
			}
			if _, ok := m["currentModeId"]; !ok {
				match = false
			}
			if match {
				if json.Unmarshal(b, &v) != nil {
					return errors.New("invalid variant payload")
				}
				u.CurrentModeUpdate = &v
				return nil
			}
		}
	} else {
		if _, ok := err.(*json.UnmarshalTypeError); !ok {
			return err
		}
	}
	{
		var v SessionUpdateUserMessageChunk
		if json.Unmarshal(b, &v) == nil {
			u.UserMessageChunk = &v
			return nil
		}
	}
	{
		var v SessionUpdateAgentMessageChunk
		if json.Unmarshal(b, &v) == nil {
			u.AgentMessageChunk = &v
			return nil
		}
	}
	{
		var v SessionUpdateAgentThoughtChunk
		if json.Unmarshal(b, &v) == nil {
			u.AgentThoughtChunk = &v
			return nil
		}
	}
	{
		var v SessionUpdateToolCall
		if json.Unmarshal(b, &v) == nil {
			u.ToolCall = &v
			return nil
		}
	}
	{
		var v SessionToolCallUpdate
		if json.Unmarshal(b, &v) == nil {
			u.ToolCallUpdate = &v
			return nil
		}
	}
	{
		var v SessionUpdatePlan
		if json.Unmarshal(b, &v) == nil {
			u.Plan = &v
			return nil
		}
	}
	{
		var v SessionAvailableCommandsUpdate
		if json.Unmarshal(b, &v) == nil {
			u.AvailableCommandsUpdate = &v
			return nil
		}
	}
	{
		var v SessionCurrentModeUpdate
		if json.Unmarshal(b, &v) == nil {
			u.CurrentModeUpdate = &v
			return nil
		}
	}
	return nil
}
func (u SessionUpdate) MarshalJSON() ([]byte, error) {
	if u.UserMessageChunk != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.UserMessageChunk)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		m["sessionUpdate"] = "user_message_chunk"
		return json.Marshal(m)
	}
	if u.AgentMessageChunk != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.AgentMessageChunk)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		m["sessionUpdate"] = "agent_message_chunk"
		return json.Marshal(m)
	}
	if u.AgentThoughtChunk != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.AgentThoughtChunk)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		m["sessionUpdate"] = "agent_thought_chunk"
		return json.Marshal(m)
	}
	if u.ToolCall != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.ToolCall)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		m["sessionUpdate"] = "tool_call"
		return json.Marshal(m)
	}
	if u.ToolCallUpdate != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.ToolCallUpdate)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		m["sessionUpdate"] = "tool_call_update"
		return json.Marshal(m)
	}
	if u.Plan != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.Plan)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		m["sessionUpdate"] = "plan"
		return json.Marshal(m)
	}
	if u.AvailableCommandsUpdate != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.AvailableCommandsUpdate)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		m["sessionUpdate"] = "available_commands_update"
		return json.Marshal(m)
	}
	if u.CurrentModeUpdate != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.CurrentModeUpdate)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		m["sessionUpdate"] = "current_mode_update"
		return json.Marshal(m)
	}
	return []byte{}, nil
}

func (u *SessionUpdate) Validate() error {
	var count int
	if u.UserMessageChunk != nil {
		count++
	}
	if u.AgentMessageChunk != nil {
		count++
	}
	if u.AgentThoughtChunk != nil {
		count++
	}
	if u.ToolCall != nil {
		count++
	}
	if u.ToolCallUpdate != nil {
		count++
	}
	if u.Plan != nil {
		count++
	}
	if u.AvailableCommandsUpdate != nil {
		count++
	}
	if u.CurrentModeUpdate != nil {
		count++
	}
	if count != 1 {
		return errors.New("SessionUpdate must have exactly one variant set")
	}
	return nil
}

// Request parameters for setting a session mode.
type SetSessionModeRequest struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// The ID of the mode to set.
	ModeId SessionModeId `json:"modeId"`
	// The ID of the session to set the mode for.
	SessionId SessionId `json:"sessionId"`
}

func (v *SetSessionModeRequest) Validate() error {
	return nil
}

// Response to 'session/set_mode' method.
type SetSessionModeResponse struct {
	Meta map[string]any `json:"_meta,omitempty"`
}

func (v *SetSessionModeResponse) Validate() error {
	return nil
}

// Reasons why an agent stops processing a prompt turn.
//
// See protocol docs: [Stop Reasons](https://agentclientprotocol.com/protocol/prompt-turn#stop-reasons)
type StopReason string

const (
	StopReasonEndTurn         StopReason = "end_turn"
	StopReasonMaxTokens       StopReason = "max_tokens"
	StopReasonMaxTurnRequests StopReason = "max_turn_requests"
	StopReasonRefusal         StopReason = "refusal"
	StopReasonCancelled       StopReason = "cancelled"
)

// Embed a terminal created with 'terminal/create' by its id.
//
// The terminal must be added before calling 'terminal/release'.
//
// See protocol docs: [Terminal](https://agentclientprotocol.com/protocol/terminals)
type Terminal struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta       map[string]any `json:"_meta,omitempty"`
	TerminalId string         `json:"terminalId"`
}

// Exit status of a terminal command.
type TerminalExitStatus struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// The process exit code (may be null if terminated by signal).
	ExitCode *int `json:"exitCode,omitempty"`
	// The signal that terminated the process (may be null if exited normally).
	Signal *string `json:"signal,omitempty"`
}

// Request to get the current output and status of a terminal.
type TerminalOutputRequest struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// The session ID for this request.
	SessionId SessionId `json:"sessionId"`
	// The ID of the terminal to get output from.
	TerminalId string `json:"terminalId"`
}

func (v *TerminalOutputRequest) Validate() error {
	if v.TerminalId == "" {
		return fmt.Errorf("terminalId is required")
	}
	return nil
}

// Response containing the terminal output and exit status.
type TerminalOutputResponse struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// Exit status if the command has completed.
	ExitStatus *TerminalExitStatus `json:"exitStatus,omitempty"`
	// The terminal output captured so far.
	Output string `json:"output"`
	// Whether the output was truncated due to byte limits.
	Truncated bool `json:"truncated"`
}

func (v *TerminalOutputResponse) Validate() error {
	if v.Output == "" {
		return fmt.Errorf("output is required")
	}
	return nil
}

// Text provided to or from an LLM.
type TextContent struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta        map[string]any `json:"_meta,omitempty"`
	Annotations *Annotations   `json:"annotations,omitempty"`
	Text        string         `json:"text"`
}

// Text-based resource contents.
type TextResourceContents struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta     map[string]any `json:"_meta,omitempty"`
	MimeType *string        `json:"mimeType,omitempty"`
	Text     string         `json:"text"`
	Uri      string         `json:"uri"`
}

// Represents a tool call that the language model has requested.
//
// Tool calls are actions that the agent executes on behalf of the language model,
// such as reading files, executing code, or fetching data from external sources.
//
// See protocol docs: [Tool Calls](https://agentclientprotocol.com/protocol/tool-calls)
type ToolCall struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// Content produced by the tool call.
	Content []ToolCallContent `json:"content,omitempty"`
	// The category of tool being invoked.
	// Helps clients choose appropriate icons and UI treatment.
	Kind ToolKind `json:"kind,omitempty"`
	// File locations affected by this tool call.
	// Enables "follow-along" features in clients.
	Locations []ToolCallLocation `json:"locations,omitempty"`
	// Raw input parameters sent to the tool.
	RawInput any `json:"rawInput,omitempty"`
	// Raw output returned by the tool.
	RawOutput any `json:"rawOutput,omitempty"`
	// Current execution status of the tool call.
	Status ToolCallStatus `json:"status,omitempty"`
	// Human-readable title describing what the tool is doing.
	Title string `json:"title"`
	// Unique identifier for this tool call within the session.
	ToolCallId ToolCallId `json:"toolCallId"`
}

// Content produced by a tool call.
//
// Tool calls can produce different types of content including
// standard content blocks (text, images) or file diffs.
//
// See protocol docs: [Content](https://agentclientprotocol.com/protocol/tool-calls#content)
// Standard content block (text, images, resources).
type ToolCallContentContent struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// The actual content block.
	Content ContentBlock `json:"content"`
	Type    string       `json:"type"`
}

// File modification shown as a diff.
type ToolCallContentDiff struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// The new content after modification.
	NewText string `json:"newText"`
	// The original content (None for new files).
	OldText *string `json:"oldText,omitempty"`
	// The file path being modified.
	Path string `json:"path"`
	Type string `json:"type"`
}

// Embed a terminal created with 'terminal/create' by its id.
//
// The terminal must be added before calling 'terminal/release'.
//
// See protocol docs: [Terminal](https://agentclientprotocol.com/protocol/terminals)
type ToolCallContentTerminal struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta       map[string]any `json:"_meta,omitempty"`
	TerminalId string         `json:"terminalId"`
	Type       string         `json:"type"`
}

type ToolCallContent struct {
	// Standard content block (text, images, resources).
	Content *ToolCallContentContent `json:"-"`
	// File modification shown as a diff.
	Diff *ToolCallContentDiff `json:"-"`
	// Embed a terminal created with 'terminal/create' by its id.
	//
	// The terminal must be added before calling 'terminal/release'.
	//
	// See protocol docs: [Terminal](https://agentclientprotocol.com/protocol/terminals)
	Terminal *ToolCallContentTerminal `json:"-"`
}

func (u *ToolCallContent) UnmarshalJSON(b []byte) error {
	var m map[string]json.RawMessage
	if err := json.Unmarshal(b, &m); err == nil {
		{
			var disc string
			if v, ok := m["type"]; ok {
				json.Unmarshal(v, &disc)
			}
			switch disc {
			case "content":
				var v ToolCallContentContent
				if json.Unmarshal(b, &v) != nil {
					return errors.New("invalid variant payload")
				}
				u.Content = &v
				return nil
			case "diff":
				var v ToolCallContentDiff
				if json.Unmarshal(b, &v) != nil {
					return errors.New("invalid variant payload")
				}
				u.Diff = &v
				return nil
			case "terminal":
				var v ToolCallContentTerminal
				if json.Unmarshal(b, &v) != nil {
					return errors.New("invalid variant payload")
				}
				u.Terminal = &v
				return nil
			}
		}
		{
			var v ToolCallContentContent
			var match bool = true
			if _, ok := m["type"]; !ok {
				match = false
			}
			if _, ok := m["content"]; !ok {
				match = false
			}
			if match {
				if json.Unmarshal(b, &v) != nil {
					return errors.New("invalid variant payload")
				}
				u.Content = &v
				return nil
			}
		}
		{
			var v ToolCallContentDiff
			var match bool = true
			if _, ok := m["type"]; !ok {
				match = false
			}
			if _, ok := m["path"]; !ok {
				match = false
			}
			if _, ok := m["newText"]; !ok {
				match = false
			}
			if match {
				if json.Unmarshal(b, &v) != nil {
					return errors.New("invalid variant payload")
				}
				u.Diff = &v
				return nil
			}
		}
		{
			var v ToolCallContentTerminal
			var match bool = true
			if _, ok := m["type"]; !ok {
				match = false
			}
			if _, ok := m["terminalId"]; !ok {
				match = false
			}
			if match {
				if json.Unmarshal(b, &v) != nil {
					return errors.New("invalid variant payload")
				}
				u.Terminal = &v
				return nil
			}
		}
	} else {
		if _, ok := err.(*json.UnmarshalTypeError); !ok {
			return err
		}
	}
	{
		var v ToolCallContentContent
		if json.Unmarshal(b, &v) == nil {
			u.Content = &v
			return nil
		}
	}
	{
		var v ToolCallContentDiff
		if json.Unmarshal(b, &v) == nil {
			u.Diff = &v
			return nil
		}
	}
	{
		var v ToolCallContentTerminal
		if json.Unmarshal(b, &v) == nil {
			u.Terminal = &v
			return nil
		}
	}
	return nil
}
func (u ToolCallContent) MarshalJSON() ([]byte, error) {
	if u.Content != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.Content)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		m["type"] = "content"
		return json.Marshal(m)
	}
	if u.Diff != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.Diff)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		m["type"] = "diff"
		return json.Marshal(m)
	}
	if u.Terminal != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.Terminal)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		m["type"] = "terminal"
		return json.Marshal(m)
	}
	return []byte{}, nil
}

func (u *ToolCallContent) Validate() error {
	var count int
	if u.Content != nil {
		count++
	}
	if u.Diff != nil {
		count++
	}
	if u.Terminal != nil {
		count++
	}
	if count != 1 {
		return errors.New("ToolCallContent must have exactly one variant set")
	}
	return nil
}

// Unique identifier for a tool call within a session.
type ToolCallId string

// A file location being accessed or modified by a tool.
//
// Enables clients to implement "follow-along" features that track
// which files the agent is working with in real-time.
//
// See protocol docs: [Following the Agent](https://agentclientprotocol.com/protocol/tool-calls#following-the-agent)
type ToolCallLocation struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// Optional line number within the file.
	Line *int `json:"line,omitempty"`
	// The file path being accessed or modified.
	Path string `json:"path"`
}

// Execution status of a tool call.
//
// Tool calls progress through different statuses during their lifecycle.
//
// See protocol docs: [Status](https://agentclientprotocol.com/protocol/tool-calls#status)
type ToolCallStatus string

const (
	ToolCallStatusPending    ToolCallStatus = "pending"
	ToolCallStatusInProgress ToolCallStatus = "in_progress"
	ToolCallStatusCompleted  ToolCallStatus = "completed"
	ToolCallStatusFailed     ToolCallStatus = "failed"
)

// An update to an existing tool call.
//
// Used to report progress and results as tools execute. All fields except
// the tool call ID are optional - only changed fields need to be included.
//
// See protocol docs: [Updating](https://agentclientprotocol.com/protocol/tool-calls#updating)
type ToolCallUpdate struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// Replace the content collection.
	Content []ToolCallContent `json:"content,omitempty"`
	// Update the tool kind.
	Kind *ToolKind `json:"kind,omitempty"`
	// Replace the locations collection.
	Locations []ToolCallLocation `json:"locations,omitempty"`
	// Update the raw input.
	RawInput any `json:"rawInput,omitempty"`
	// Update the raw output.
	RawOutput any `json:"rawOutput,omitempty"`
	// Update the execution status.
	Status *ToolCallStatus `json:"status,omitempty"`
	// Update the human-readable title.
	Title *string `json:"title,omitempty"`
	// The ID of the tool call being updated.
	ToolCallId ToolCallId `json:"toolCallId"`
}

func (t *ToolCallUpdate) Validate() error {
	if t.ToolCallId == "" {
		return fmt.Errorf("toolCallId is required")
	}
	return nil
}

// Categories of tools that can be invoked.
//
// Tool kinds help clients choose appropriate icons and optimize how they
// display tool execution progress.
//
// See protocol docs: [Creating](https://agentclientprotocol.com/protocol/tool-calls#creating)
type ToolKind string

const (
	ToolKindRead       ToolKind = "read"
	ToolKindEdit       ToolKind = "edit"
	ToolKindDelete     ToolKind = "delete"
	ToolKindMove       ToolKind = "move"
	ToolKindSearch     ToolKind = "search"
	ToolKindExecute    ToolKind = "execute"
	ToolKindThink      ToolKind = "think"
	ToolKindFetch      ToolKind = "fetch"
	ToolKindSwitchMode ToolKind = "switch_mode"
	ToolKindOther      ToolKind = "other"
)

// **UNSTABLE**
//
// This capability is not part of the spec yet, and may be removed or changed at any point.
//
// Notification to cancel an ongoing request.
//
// See protocol docs: [Cancellation](https://agentclientprotocol.com/protocol/cancellation)
type UnstableCancelRequestNotification struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// The ID of the request to cancel.
	RequestId RequestId `json:"requestId"`
}

func (v *UnstableCancelRequestNotification) Validate() error {
	return nil
}

// **UNSTABLE**
//
// This capability is not part of the spec yet, and may be removed or changed at any point.
//
// Request parameters for forking an existing session.
//
// Creates a new session based on the context of an existing one, allowing
// operations like generating summaries without affecting the original session's history.
//
// Only available if the Agent supports the 'session.fork' capability.
type UnstableForkSessionRequest struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// The working directory for this session.
	Cwd string `json:"cwd"`
	// List of MCP servers to connect to for this session.
	McpServers []McpServer `json:"mcpServers,omitempty"`
	// The ID of the session to fork.
	SessionId SessionId `json:"sessionId"`
}

func (v *UnstableForkSessionRequest) Validate() error {
	if v.Cwd == "" {
		return fmt.Errorf("cwd is required")
	}
	return nil
}

// **UNSTABLE**
//
// This capability is not part of the spec yet, and may be removed or changed at any point.
//
// Response from forking an existing session.
type UnstableForkSessionResponse struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// **UNSTABLE**
	//
	// This capability is not part of the spec yet, and may be removed or changed at any point.
	//
	// Initial session configuration options if supported by the Agent.
	ConfigOptions []UnstableSessionConfigOption `json:"configOptions,omitempty"`
	// **UNSTABLE**
	//
	// This capability is not part of the spec yet, and may be removed or changed at any point.
	//
	// Initial model state if supported by the Agent
	Models *UnstableSessionModelState `json:"models,omitempty"`
	// Initial mode state if supported by the Agent
	//
	// See protocol docs: [Session Modes](https://agentclientprotocol.com/protocol/session-modes)
	Modes *SessionModeState `json:"modes,omitempty"`
	// Unique identifier for the newly created forked session.
	SessionId SessionId `json:"sessionId"`
}

func (v *UnstableForkSessionResponse) Validate() error {
	return nil
}

// **UNSTABLE**
//
// This capability is not part of the spec yet, and may be removed or changed at any point.
//
// Request parameters for listing existing sessions.
//
// Only available if the Agent supports the 'listSessions' capability.
type UnstableListSessionsRequest struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// Opaque cursor token from a previous response's nextCursor field for cursor-based pagination
	Cursor *string `json:"cursor,omitempty"`
	// Filter sessions by working directory. Must be an absolute path.
	Cwd *string `json:"cwd,omitempty"`
}

func (v *UnstableListSessionsRequest) Validate() error {
	return nil
}

// **UNSTABLE**
//
// This capability is not part of the spec yet, and may be removed or changed at any point.
//
// Response from listing sessions.
type UnstableListSessionsResponse struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// Opaque cursor token. If present, pass this in the next request's cursor parameter
	// to fetch the next page. If absent, there are no more results.
	NextCursor *string `json:"nextCursor,omitempty"`
	// Array of session information objects
	Sessions []UnstableSessionInfo `json:"sessions"`
}

func (v *UnstableListSessionsResponse) Validate() error {
	if v.Sessions == nil {
		return fmt.Errorf("sessions is required")
	}
	return nil
}

// **UNSTABLE**
//
// This capability is not part of the spec yet, and may be removed or changed at any point.
//
// A unique identifier for a model.
type UnstableModelId string

// **UNSTABLE**
//
// This capability is not part of the spec yet, and may be removed or changed at any point.
//
// Information about a selectable model.
type UnstableModelInfo struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// Optional description of the model.
	Description *string `json:"description,omitempty"`
	// Unique identifier for the model.
	ModelId UnstableModelId `json:"modelId"`
	// Human-readable name of the model.
	Name string `json:"name"`
}

// **UNSTABLE**
//
// This capability is not part of the spec yet, and may be removed or changed at any point.
//
// Request parameters for resuming an existing session.
//
// Resumes an existing session without returning previous messages (unlike 'session/load').
// This is useful for agents that can resume sessions but don't implement full session loading.
//
// Only available if the Agent supports the 'session.resume' capability.
type UnstableResumeSessionRequest struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// The working directory for this session.
	Cwd string `json:"cwd"`
	// List of MCP servers to connect to for this session.
	McpServers []McpServer `json:"mcpServers,omitempty"`
	// The ID of the session to resume.
	SessionId SessionId `json:"sessionId"`
}

func (v *UnstableResumeSessionRequest) Validate() error {
	if v.Cwd == "" {
		return fmt.Errorf("cwd is required")
	}
	return nil
}

// **UNSTABLE**
//
// This capability is not part of the spec yet, and may be removed or changed at any point.
//
// Response from resuming an existing session.
type UnstableResumeSessionResponse struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// **UNSTABLE**
	//
	// This capability is not part of the spec yet, and may be removed or changed at any point.
	//
	// Initial session configuration options if supported by the Agent.
	ConfigOptions []UnstableSessionConfigOption `json:"configOptions,omitempty"`
	// **UNSTABLE**
	//
	// This capability is not part of the spec yet, and may be removed or changed at any point.
	//
	// Initial model state if supported by the Agent
	Models *UnstableSessionModelState `json:"models,omitempty"`
	// Initial mode state if supported by the Agent
	//
	// See protocol docs: [Session Modes](https://agentclientprotocol.com/protocol/session-modes)
	Modes *SessionModeState `json:"modes,omitempty"`
}

func (v *UnstableResumeSessionResponse) Validate() error {
	return nil
}

// **UNSTABLE**
//
// This capability is not part of the spec yet, and may be removed or changed at any point.
//
// Unique identifier for a session configuration option value group.
type UnstableSessionConfigGroupId string

// **UNSTABLE**
//
// This capability is not part of the spec yet, and may be removed or changed at any point.
//
// Unique identifier for a session configuration option.
type UnstableSessionConfigId string

// **UNSTABLE**
//
// This capability is not part of the spec yet, and may be removed or changed at any point.
//
// A session configuration option selector and its current state.
// Single-value selector (dropdown).
type UnstableSessionConfigOptionSelect struct {
	// The currently selected value.
	CurrentValue UnstableSessionConfigValueId `json:"currentValue"`
	// The set of selectable options.
	Options UnstableSessionConfigSelectOptions `json:"options"`
	Type    string                             `json:"type"`
}

type UnstableSessionConfigOption struct {
	// Single-value selector (dropdown).
	Select *UnstableSessionConfigOptionSelect `json:"-"`
}

func (u *UnstableSessionConfigOption) UnmarshalJSON(b []byte) error {
	var m map[string]json.RawMessage
	if err := json.Unmarshal(b, &m); err == nil {
		{
			var disc string
			if v, ok := m["type"]; ok {
				json.Unmarshal(v, &disc)
			}
			switch disc {
			case "select":
				var v UnstableSessionConfigOptionSelect
				if json.Unmarshal(b, &v) != nil {
					return errors.New("invalid variant payload")
				}
				u.Select = &v
				return nil
			}
		}
		{
			var v UnstableSessionConfigOptionSelect
			var match bool = true
			if _, ok := m["type"]; !ok {
				match = false
			}
			if _, ok := m["currentValue"]; !ok {
				match = false
			}
			if _, ok := m["options"]; !ok {
				match = false
			}
			if match {
				if json.Unmarshal(b, &v) != nil {
					return errors.New("invalid variant payload")
				}
				u.Select = &v
				return nil
			}
		}
	} else {
		if _, ok := err.(*json.UnmarshalTypeError); !ok {
			return err
		}
	}
	{
		var v UnstableSessionConfigOptionSelect
		if json.Unmarshal(b, &v) == nil {
			u.Select = &v
			return nil
		}
	}
	return nil
}
func (u UnstableSessionConfigOption) MarshalJSON() ([]byte, error) {
	if u.Select != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.Select)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		m["type"] = "select"
		return json.Marshal(m)
	}
	return []byte{}, nil
}

func (u *UnstableSessionConfigOption) Validate() error {
	var count int
	if u.Select != nil {
		count++
	}
	if count != 1 {
		return errors.New("UnstableSessionConfigOption must have exactly one variant set")
	}
	return nil
}

// **UNSTABLE**
//
// This capability is not part of the spec yet, and may be removed or changed at any point.
//
// Semantic category for a session configuration option.
//
// This is intended to help Clients distinguish broadly common selectors (e.g. model selector vs
// session mode selector vs thought/reasoning level) for UX purposes (keyboard shortcuts, icons,
// placement). It MUST NOT be required for correctness. Clients MUST handle missing or unknown
// categories gracefully.
//
// Category names beginning with '_' are free for custom use, like other ACP extension methods.
// Category names that do not begin with '_' are reserved for the ACP spec.
// Unknown / uncategorized selector.
type UnstableSessionConfigOptionCategoryOther struct{}

type UnstableSessionConfigOptionCategory struct {
	// Unknown / uncategorized selector.
	Other *UnstableSessionConfigOptionCategoryOther `json:"-"`
}

func (u *UnstableSessionConfigOptionCategory) UnmarshalJSON(b []byte) error {
	var m map[string]json.RawMessage
	if err := json.Unmarshal(b, &m); err == nil {
	} else {
		if _, ok := err.(*json.UnmarshalTypeError); !ok {
			return err
		}
	}
	{
		var v UnstableSessionConfigOptionCategoryOther
		if json.Unmarshal(b, &v) == nil {
			u.Other = &v
			return nil
		}
	}
	return nil
}
func (u UnstableSessionConfigOptionCategory) MarshalJSON() ([]byte, error) {
	if u.Other != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.Other)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	return []byte{}, nil
}

// **UNSTABLE**
//
// This capability is not part of the spec yet, and may be removed or changed at any point.
//
// A single-value selector (dropdown) session configuration option payload.
type UnstableSessionConfigSelect struct {
	// The currently selected value.
	CurrentValue UnstableSessionConfigValueId `json:"currentValue"`
	// The set of selectable options.
	Options UnstableSessionConfigSelectOptions `json:"options"`
}

// **UNSTABLE**
//
// This capability is not part of the spec yet, and may be removed or changed at any point.
//
// A group of possible values for a session configuration option.
type UnstableSessionConfigSelectGroup struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// Unique identifier for this group.
	Group UnstableSessionConfigGroupId `json:"group"`
	// Human-readable label for this group.
	Name string `json:"name"`
	// The set of option values in this group.
	Options []UnstableSessionConfigSelectOption `json:"options"`
}

// **UNSTABLE**
//
// This capability is not part of the spec yet, and may be removed or changed at any point.
//
// A possible value for a session configuration option.
type UnstableSessionConfigSelectOption struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// Optional description for this option value.
	Description *string `json:"description,omitempty"`
	// Human-readable label for this option value.
	Name string `json:"name"`
	// Unique identifier for this option value.
	Value UnstableSessionConfigValueId `json:"value"`
}

// **UNSTABLE**
//
// This capability is not part of the spec yet, and may be removed or changed at any point.
//
// Possible values for a session configuration option.
// A flat list of options with no grouping.
type UnstableSessionConfigSelectOptionsUngrouped struct{}

// A list of options grouped under headers.
type UnstableSessionConfigSelectOptionsGrouped struct{}

type UnstableSessionConfigSelectOptions struct {
	// A flat list of options with no grouping.
	Ungrouped *UnstableSessionConfigSelectOptionsUngrouped `json:"-"`
	// A list of options grouped under headers.
	Grouped *UnstableSessionConfigSelectOptionsGrouped `json:"-"`
}

func (u *UnstableSessionConfigSelectOptions) UnmarshalJSON(b []byte) error {
	var m map[string]json.RawMessage
	if err := json.Unmarshal(b, &m); err == nil {
	} else {
		if _, ok := err.(*json.UnmarshalTypeError); !ok {
			return err
		}
	}
	{
		var v UnstableSessionConfigSelectOptionsUngrouped
		if json.Unmarshal(b, &v) == nil {
			u.Ungrouped = &v
			return nil
		}
	}
	{
		var v UnstableSessionConfigSelectOptionsGrouped
		if json.Unmarshal(b, &v) == nil {
			u.Grouped = &v
			return nil
		}
	}
	return nil
}
func (u UnstableSessionConfigSelectOptions) MarshalJSON() ([]byte, error) {
	if u.Ungrouped != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.Ungrouped)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	if u.Grouped != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.Grouped)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	return []byte{}, nil
}

// **UNSTABLE**
//
// This capability is not part of the spec yet, and may be removed or changed at any point.
//
// Unique identifier for a session configuration option value.
type UnstableSessionConfigValueId string

// **UNSTABLE**
//
// This capability is not part of the spec yet, and may be removed or changed at any point.
//
// Information about a session returned by session/list
type UnstableSessionInfo struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// The working directory for this session. Must be an absolute path.
	Cwd string `json:"cwd"`
	// Unique identifier for the session
	SessionId SessionId `json:"sessionId"`
	// Human-readable title for the session
	Title *string `json:"title,omitempty"`
	// ISO 8601 timestamp of last activity
	UpdatedAt *string `json:"updatedAt,omitempty"`
}

// **UNSTABLE**
//
// This capability is not part of the spec yet, and may be removed or changed at any point.
//
// The set of models and the one currently active.
type UnstableSessionModelState struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// The set of models that the Agent can use
	AvailableModels []UnstableModelInfo `json:"availableModels"`
	// The current model the Agent is in.
	CurrentModelId UnstableModelId `json:"currentModelId"`
}

// **UNSTABLE**
//
// This capability is not part of the spec yet, and may be removed or changed at any point.
//
// Request parameters for setting a session configuration option.
type UnstableSetSessionConfigOptionRequest struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// The ID of the configuration option to set.
	ConfigId UnstableSessionConfigId `json:"configId"`
	// The ID of the session to set the configuration option for.
	SessionId SessionId `json:"sessionId"`
	// The ID of the configuration option value to set.
	Value UnstableSessionConfigValueId `json:"value"`
}

func (v *UnstableSetSessionConfigOptionRequest) Validate() error {
	return nil
}

// **UNSTABLE**
//
// This capability is not part of the spec yet, and may be removed or changed at any point.
//
// Response to 'session/set_config_option' method.
type UnstableSetSessionConfigOptionResponse struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// The full set of configuration options and their current values.
	ConfigOptions []UnstableSessionConfigOption `json:"configOptions"`
}

func (v *UnstableSetSessionConfigOptionResponse) Validate() error {
	if v.ConfigOptions == nil {
		return fmt.Errorf("configOptions is required")
	}
	return nil
}

// **UNSTABLE**
//
// This capability is not part of the spec yet, and may be removed or changed at any point.
//
// Request parameters for setting a session model.
type UnstableSetSessionModelRequest struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// The ID of the model to set.
	ModelId UnstableModelId `json:"modelId"`
	// The ID of the session to set the model for.
	SessionId SessionId `json:"sessionId"`
}

func (v *UnstableSetSessionModelRequest) Validate() error {
	return nil
}

// **UNSTABLE**
//
// This capability is not part of the spec yet, and may be removed or changed at any point.
//
// Response to 'session/set_model' method.
type UnstableSetSessionModelResponse struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
}

func (v *UnstableSetSessionModelResponse) Validate() error {
	return nil
}

// All text that was typed after the command name is provided as input.
type UnstructuredCommandInput struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// A hint to display when the input hasn't been provided yet
	Hint string `json:"hint"`
}

// Request to wait for a terminal command to exit.
type WaitForTerminalExitRequest struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// The session ID for this request.
	SessionId SessionId `json:"sessionId"`
	// The ID of the terminal to wait for.
	TerminalId string `json:"terminalId"`
}

func (v *WaitForTerminalExitRequest) Validate() error {
	if v.TerminalId == "" {
		return fmt.Errorf("terminalId is required")
	}
	return nil
}

// Response containing the exit status of a terminal command.
type WaitForTerminalExitResponse struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// The process exit code (may be null if terminated by signal).
	ExitCode *int `json:"exitCode,omitempty"`
	// The signal that terminated the process (may be null if exited normally).
	Signal *string `json:"signal,omitempty"`
}

func (v *WaitForTerminalExitResponse) Validate() error {
	return nil
}

// Request to write content to a text file.
//
// Only available if the client supports the 'fs.writeTextFile' capability.
type WriteTextFileRequest struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
	// The text content to write to the file.
	Content string `json:"content"`
	// Absolute path to the file to write.
	Path string `json:"path"`
	// The session ID for this request.
	SessionId SessionId `json:"sessionId"`
}

func (v *WriteTextFileRequest) Validate() error {
	if v.Content == "" {
		return fmt.Errorf("content is required")
	}
	if v.Path == "" {
		return fmt.Errorf("path is required")
	}
	return nil
}

// Response to 'fs/write_text_file'
type WriteTextFileResponse struct {
	// The _meta property is reserved by ACP to allow clients and agents to attach additional
	// metadata to their interactions. Implementations MUST NOT make assumptions about values at
	// these keys.
	//
	// See protocol docs: [Extensibility](https://agentclientprotocol.com/protocol/extensibility)
	Meta map[string]any `json:"_meta,omitempty"`
}

func (v *WriteTextFileResponse) Validate() error {
	return nil
}

type Agent interface {
	// Request parameters for the authenticate method.
	//
	// Specifies which authentication method to use.
	Authenticate(ctx context.Context, params AuthenticateRequest) (AuthenticateResponse, error)
	// Request parameters for the initialize method.
	//
	// Sent by the client to establish connection and negotiate capabilities.
	//
	// See protocol docs: [Initialization](https://agentclientprotocol.com/protocol/initialization)
	Initialize(ctx context.Context, params InitializeRequest) (InitializeResponse, error)
	// Notification to cancel ongoing operations for a session.
	//
	// See protocol docs: [Cancellation](https://agentclientprotocol.com/protocol/prompt-turn#cancellation)
	Cancel(ctx context.Context, params CancelNotification) error
	// Request parameters for creating a new session.
	//
	// See protocol docs: [Creating a Session](https://agentclientprotocol.com/protocol/session-setup#creating-a-session)
	NewSession(ctx context.Context, params NewSessionRequest) (NewSessionResponse, error)
	// Request parameters for sending a user prompt to the agent.
	//
	// Contains the user's message and any additional context.
	//
	// See protocol docs: [User Message](https://agentclientprotocol.com/protocol/prompt-turn#1-user-message)
	Prompt(ctx context.Context, params PromptRequest) (PromptResponse, error)
	// Request parameters for setting a session mode.
	SetSessionMode(ctx context.Context, params SetSessionModeRequest) (SetSessionModeResponse, error)
}

// AgentLoader defines optional support for loading sessions. Implement and advertise the capability to enable 'session/load'.
type AgentLoader interface {
	// Request parameters for loading an existing session.
	//
	// Only available if the Agent supports the 'loadSession' capability.
	//
	// See protocol docs: [Loading Sessions](https://agentclientprotocol.com/protocol/session-setup#loading-sessions)
	LoadSession(ctx context.Context, params LoadSessionRequest) (LoadSessionResponse, error)
}

// AgentExperimental defines unstable methods that are not part of the official spec. These may change or be removed without notice.
type AgentExperimental interface {
	// **UNSTABLE**
	//
	// This capability is not part of the spec yet, and may be removed or changed at any point.
	//
	// Request parameters for forking an existing session.
	//
	// Creates a new session based on the context of an existing one, allowing
	// operations like generating summaries without affecting the original session's history.
	//
	// Only available if the Agent supports the 'session.fork' capability.
	UnstableForkSession(ctx context.Context, params UnstableForkSessionRequest) (UnstableForkSessionResponse, error)
	// **UNSTABLE**
	//
	// This capability is not part of the spec yet, and may be removed or changed at any point.
	//
	// Request parameters for listing existing sessions.
	//
	// Only available if the Agent supports the 'listSessions' capability.
	UnstableListSessions(ctx context.Context, params UnstableListSessionsRequest) (UnstableListSessionsResponse, error)
	// **UNSTABLE**
	//
	// This capability is not part of the spec yet, and may be removed or changed at any point.
	//
	// Request parameters for resuming an existing session.
	//
	// Resumes an existing session without returning previous messages (unlike 'session/load').
	// This is useful for agents that can resume sessions but don't implement full session loading.
	//
	// Only available if the Agent supports the 'session.resume' capability.
	UnstableResumeSession(ctx context.Context, params UnstableResumeSessionRequest) (UnstableResumeSessionResponse, error)
	// **UNSTABLE**
	//
	// This capability is not part of the spec yet, and may be removed or changed at any point.
	//
	// Request parameters for setting a session configuration option.
	UnstableSetSessionConfigOption(ctx context.Context, params UnstableSetSessionConfigOptionRequest) (UnstableSetSessionConfigOptionResponse, error)
	// **UNSTABLE**
	//
	// This capability is not part of the spec yet, and may be removed or changed at any point.
	//
	// Request parameters for setting a session model.
	UnstableSetSessionModel(ctx context.Context, params UnstableSetSessionModelRequest) (UnstableSetSessionModelResponse, error)
}
type Client interface {
	// Request to read content from a text file.
	//
	// Only available if the client supports the 'fs.readTextFile' capability.
	ReadTextFile(ctx context.Context, params ReadTextFileRequest) (ReadTextFileResponse, error)
	// Request to write content to a text file.
	//
	// Only available if the client supports the 'fs.writeTextFile' capability.
	WriteTextFile(ctx context.Context, params WriteTextFileRequest) (WriteTextFileResponse, error)
	// Request for user permission to execute a tool call.
	//
	// Sent when the agent needs authorization before performing a sensitive operation.
	//
	// See protocol docs: [Requesting Permission](https://agentclientprotocol.com/protocol/tool-calls#requesting-permission)
	RequestPermission(ctx context.Context, params RequestPermissionRequest) (RequestPermissionResponse, error)
	// Notification containing a session update from the agent.
	//
	// Used to stream real-time progress and results during prompt processing.
	//
	// See protocol docs: [Agent Reports Output](https://agentclientprotocol.com/protocol/prompt-turn#3-agent-reports-output)
	SessionUpdate(ctx context.Context, params SessionNotification) error
	// Request to create a new terminal and execute a command.
	CreateTerminal(ctx context.Context, params CreateTerminalRequest) (CreateTerminalResponse, error)
	// Request to kill a terminal command without releasing the terminal.
	KillTerminalCommand(ctx context.Context, params KillTerminalCommandRequest) (KillTerminalCommandResponse, error)
	// Request to get the current output and status of a terminal.
	TerminalOutput(ctx context.Context, params TerminalOutputRequest) (TerminalOutputResponse, error)
	// Request to release a terminal and free its resources.
	ReleaseTerminal(ctx context.Context, params ReleaseTerminalRequest) (ReleaseTerminalResponse, error)
	// Request to wait for a terminal command to exit.
	WaitForTerminalExit(ctx context.Context, params WaitForTerminalExitRequest) (WaitForTerminalExitResponse, error)
}

// ClientExperimental defines unstable methods that are not part of the official spec. These may change or be removed without notice.
type ClientExperimental interface{}
